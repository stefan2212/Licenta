\documentclass[12]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[romanian]{babel}
\usepackage{amsfonts}
\usepackage{combelow}% provides \cb to place comma below character
\usepackage{systeme}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{flexisym}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,     
}
 
\urlstyle{same}
\begin{document}




\tableofcontents
\chapter{Introducere în RSA}
\section{RSA Clasic}
\subsection{Descriere}

RSA este un algoritm criptografic cu chei publice, primul algoritm utilizat atât pentru criptare, cât și pentru semnătura electronică. Algoritmul a fost dezvoltt în 1977 și publicat în 1978 de Ron Rivest, Adi Shamir și Leonard Adleman la MIT, iar numele algoritmului provine din inițialele lor. \\
Securitatea sa se bazează pe dificultatea problemei factorizării numerelor întregi, problemă la care se reduce criptanaliza RSA și pentru care toți algoritmii de rezolvare cunoscuți au complexitate exponențială. Există câteva metode de criptanaliză care ocolesc factorizarea efectivă, exploatând maniere de implementare efectivă a schemei de criptare.
\subsection{Funcționare}
RSA este un algoritm de criptare pe blocuri. Acesta înseamnă că atât textul clar cât și cel criptat sunt numere între 0 și $N-1$, cu un $N$ ales. Un mesaj este împărțit în segmente de lungime corespunzătoare, numit blocuri, care sunt cifrate rând pe rând. De asemenea, ca algoritm criptografic cu chei publice, funcționează pe baza unei perechi de chei legate matematic între ele: o cheie publică, cunoscută de toată lumea, și una secretă, cunoscută doar de deținătorul acesteia.
\subsection{Generarea cheilor}
Perechea de chei se generează după următorii pași:
\begin{enumerate}
\item Se generează două numere prime, de preferat mari, $P$ și $Q$
\item Se calculează $N=PQ$ și $\phi(N)=(P-1)(Q-1)$
\item Se generează un număr întreg aleator $e$ , $1<e<\phi(N)$, astfel încât $gcd(e,\phi(N))=1$, perechea $<N,e>$ este cheia publică.
\item Folosind algoritmul lui Euclid extins, se calculează întregul $d$ , element din $\mathbb{Z}_{\phi(N)}^{*}$, cu proprietatea că $de \equiv 1 \ mod \ \phi(N)$
\end{enumerate}
\subsection{Criptare și Decriptare}
Presupunând că mesajul clar este sub forma unui număr $m$, mai mic decât $N$, atunci mesajul criptat, notat cu $c$ este:
$$c = m^e \ mod \ N$$
Unde $e$ este cheia publică a destinatarului mesajului. Pentru a decripta mesaju, destinatarul își folosește cheia sa secretă $d$, care are proprietatea foarte importantă că:
$$de \equiv 1 \ mod \ \phi(N)$$
Astfel, mesajul clar este recuperat calculând:
$$m = c^d \ mod \ N$$
Oricine poate decripta mesaje cu cheia publică a destinatarului, dar numai acesta din urmă poate decripta, deoarece trebuie să folosească cheia sa secretă.
\subsection{Implementări eficiente}
În general, deoarece se bzează pe o operație destul de costisitoare din punct de vedere al timpului de calcul și al resurselor folosite, și anume exponențierea modulo $n$, viteza RSA este mult mai mică decât a algoritmilor de criptare cu cheie secretă. În jurul anilor 90, se estima că o implementare RSA hardware este de 1000 de ori mai lentă decât o implementare DES, iar în software, RSA este de 100 de ori mai lent. \\
Există anumite modificări care pot aduce performanțe sporite, precum alegerea unui exponent de criptare mic (de exemplu $e=17$), care astfel reduce calculele necesare criptării, rezolvând în același timp și unele probleme de securitate. De asemenea, operațiile cu cheia secretă pot fi accelerate pe baza teoremei chineze a resturilor, dacă se stochează $P$,$Q$ și unele rezultate intermediare, foloside des.  Viteza decriptării va crește de circa 4 ori. De aceea, în sistemele de comunicație în timp real, în care viteza de criptare și decriptare este esențială (cum ar fi de exemplu aplicațiile de streaming video sau audio securizate), RSA se folosește doar la începutul comunicației, pentru a transmite ceia secretă de comunicație, care ulterior este folosită într-un algoritm cu cheie secretă, cum ar fi 3DES sau AES.
\subsection{Securitatea}
Problema decriptării unui mesaj criptat cu RSA este denumită problema RSA. Acesta constă în obținerea rădăcinii de ordin $e$ modulo $N$, unde $e$ și $N$ au proprietatea că $N$ este produsul a două numere prime mari $P$ și $Q$, iar $e$ este relativ prim cu produsul dintre $P-1$ și $Q-1$. În acest moment, cea mai eficientă de a realiza aeasta este descompunerea în factori primi ai lui $n$, și obținerea astfel a cheii secrete $d$ pe baza lui $e$. Astfel, este demonstrat că dificultatea spargerii unui mesaj criptat cu RSA nu este mai dificilă decât problema factorizării. Nu a fost descoperită încă o soluție generală a problemei RSA, dar nici nu s-a demonstrat matematic că nu există o altă soluție. \\
Factorizarea întregilor prin metode comune ajută la găsirea soluțiilor în timp util doar pentru numere mici. Pentru numere mari, algoritmii de factorizare, cu complexitatea exponențială. dau soluția după foarte mult timp. Cea mai rapidă metodă de factorizare a întregilor, algoritmul ”Number Field Siev”, are o complexitate de $O(e^{c((\log n)^{\frac{1}{3}} (\log \log n)^{\frac{2}{3}}       })$. Aici, $c$ este un număr ce ia valori în jur de $1,9$ pentru numere de tipul lui $N$, adică numere cu 2 factori primi. Cel mai mare număr factorizat vreodată prin acest algoritm, rulat în anul 2005, de către specialiștii de la Agenția Federală Germană pentru Securitatea Tehnologiei Informației, are 200 de cifre zecimale, iar reprezentarea binară a factorilor primi obținuți ocupă 663 de biți. Cheile de criptare RSA cele mai sigure au lungimi de peste 1024 de biți.\\
Atacul RSA forței brute, adică încercarea fiecărei chei secrete posibile, consumă chiar mai mult timp decât factorizarea.
\chapter{Criptanaliză RSA}
\section{Criptanaliză pe RSA clasic}
Deși securitatea algoritmului RSA constă în legătura dintre aceasta și factorizarea întregilor, el trebuie folosit u grijă în implementări, deoarece, în caz de folosire eronată, sistemele bazate pe RSA pot fi atacate în anumite maniere care ocolesc factorizarea efectiva a modului, atacatorul ajungând să obțină mesajul clar sau cheia secreă.
\subsection{Atac cu criptotext ales}
În cazul acestui atac, adversarul dispune de cheia publică a entității atacate (exponentul de criptare $e$ și modulul $N$), și interceptează mesaje criptate trimise acestuia. Pentru a obține mesajul clar $m$ dintr-un mesaj criptat $c$ atacatorul poate proceda în felul următor:
\begin{enumerate}
\item Calculează $x=(c * 2^e) \ mod \ N$
\item Trimite entității atacate spre semnare pe $x$, obținând $y=x^d \ mod \ N$
\item Se observă că: 
$$x=c*2^e \ mod \ N $$
$$=m^e * 2^e \ mod \ N$$
$$=(2m)^e \ mod \ N$$ 
\item Se rezolvă ecuația $y=2m \ mod \ N$
\end{enumerate}
Atacatorul obține astfel mesajul criptat. Există mai multe feluri de tipul atac cu criptotext ales, dar sunt câteva moduri de apărare împotriva lor. Unele pot fi evitate dacă pur și simplu entitatea protejată cu chei secrete refuză să semneze texte arbitrare trimise de terți. Dacă acest lucru nu este posibil ( ca de exemplu în cazul unui notar public care trebuie să semneze documente electronice prezentate de persoane străine), atunci atacul poate fi prevenit prin folosirea unei perechi de diferite chei pentru criptare și pentru semnătura electronică. De asemenea, este necesar să se folosească și un padding aleator pentru mesaj înainte de criptare sau, în cazul semnăturii, să nu semneze mesajul clar, ci un has al acestuia. De asemenea, atacul poate fi evitat și dacă se impune o anumită structură predefinită a mesajelor primite spre semnare.
\subsection{Mesaje necriptate}
Întrucât RSA se bazează pe ridicarea la putere (modulo un număr $N$), există părți de mesaje care nu sunt criptate, părți rezultate în urma împărțirii mesajului pe blocuri. Astfel de mesaje sunt mesajele $m$ cu proprietatea că $m=m^x \ mod \ N$ oricare ar fi $x$, ca de exemplu $m=0$,$m=1$,$m=N-1$. Numărul exact al acestor mesaje decriptate este $(1+gcd(e-1,P-1))((1+gcd(e-1,Q-1))$, și deși este minim 0(deoarece $e$,$p$ și$q$ sunt impare). Pentru a micșora numărul de astfel de părți de mesaj, este util să se folosească un exponent public $e$ cât mai mic.
\subsection{Exponentul de criptare mic}
În unele aplicații, se folosește un exponent de criptare $e$ mic, de exemplu $e=17$, pentru a mări performanța, dar și pentru a rezolva unele probleme de securitate. Dacă mai multe entități care comunică folosesc același exponent public (dar fiecare are propriul modul și deci propria cheie secretă), atunci același mesaj trimis mai multor destinatari are următoarele valori:

\[
\left\{ 
\begin{array}{c}
c_1 = m^e \ mod \ N_1 \\ 
c_2 = m^e \ mod \ N_2 \\ 
c_3 = m^e \ mod \ N_3
\end{array}
\right. 
\]
Unde $N_i$ sunt modulele elor trei destinatari, $e$ este exponentul  comun acestora iar $m$ este mesajul trimis celor trei. Un atacator poate folosi algoritmul lui Gauss pentru a descoperi o soluție mai mică decât $N_1$,$N_2$,$N_3$ a unui sistem compus din următoarele ecuații
\[
\left\{ 
\begin{array}{c}
x=m^e \ mod \ N_1  \\
x=m^e \ mod \ N_2  \\
x=m^e \ mod \ N_3  
\end{array}
\right. 
\]
Această soluție este, conform teoremei chineze a resturilor, cubul mesajului m. Soluția pentru această problemă este cea denumită sărarea mesajului ( din engleză salting), adică adăugarea unui padding format din numere pseudoaleatoare, padding diferit pentru fiecare expediere a mesajuului.

\subsubsection{Atac de tip mesaj stereotip}
Când o parte din plaintext este cunoscută, este posibil să se recupereze tot plaintextul inițial dacă dimensiunea exponentului este destul de mică. \\
În cazuri extreme, presupunem că noi cunoaștem că plaintextul este mic relativ la dimensiunea modulului. Asta înseamnă că cei mai semnificativi biți ai plaintextului vor fi 0. Dacă plaintextul $m < N^{1/e}$ este cryptat cu exponentul $e$, atunci cu siguranță plaintextul va ri recuperat ușor deoarece:
$$ c = m^e \ mod \ N = m^e$$
Doar luând $e$ rădăcina unui criptotext, vom putea descoperi un plaintext. Pentru un plaintext aleator $m$ în $\mathbb{Z}_N$ este foarte improbabil ca și acesta să fie mic. \\
Așadar, dacă dimensiunea lui $N$ ar fi de 1024 de biți iar $e=3$, atunci plaintextele mai mici de 342 de biți pot fi recuperate foarte ușor. Padând biți random unui plaintext în așa fel încât $m > N^{1/e}$ împiedică acest atac. \\
Acum să presupunem că avem un plaintext de dimensiune mare, asta ar însemna că acest atac nu ar putea funcționa, dar totuși noi cunoaștem o bucată din acest text, spre exemplu: \\
Astăzi la licență am prezentat ???????? \\
unde partea pe care nu o cunoaștem este destul de mică. În această situație, Copper-smith \cite{cooper} \cite{cooper2} ne arată că dacă partea necunoscută a unui text este destul de mică, este posibil să recuperăm întreg plaintextul. Rezultatul de bază este dat de următoare teoremă: \\
\textbf{Teorema 4.1}
Fie $<N,e>$ o cheie RSA publică, și $m$ plaintextul. Cheia publică $e$ este folosită pentru calculul criptotextului $c = m^e \ mod \ N$, dacă toate sau măcar o fracție $1/e$ de biți consecutivi este cunoscută, atunci tot plaintextul $m$ poate fi calculat în timpul $\log(N)$. \\
Demonstrație: Deoarece măcar o fracție $1/e$ de biți consecutivi este cunoscută din $m$, putem scrie plaintextul ca și:
$$ m= m_{2}^{} * 2^{k_2} + m_1 * 2^{k_1} + m_0$$
Unde toți acești termeni sunt cunoscuți, mai puțin $m_1$. Mai departe știm  că dimensiunea lui $m_1$ satisface următoarea relație $ |m_1| < N^{1/e}$. Acest lucru sugerează că trebuie să ne uităm după soluții mici ale polinomului monic de grad e $f_N(x) \in \mathbb{Z}_N $ (un polinom monic este un polinom univariat al cărui coeficient al termenului $X^n$ este egal cu 1, iar un polinom univariat este un polinom care are o singură variabilă $x$) dat de următoarea formulă:
$$ f_N(x) = 2^{-k_1 * e}((m_2 * 2^{k_2} + x*2^{k_1} + m_0)^e - e) \ mod \ N$$
deoarece $f_N(m_1)= 2^{-k_1 *e}(m^e-e)=0 \ mod \ N$. Deoarece $ |m_1| < N^{1/e}$, rezultatul Copersmith pentru găsirea soluțiilor mici pentru ecuațiile modulare univariate poate fi folosit pentru a calcula $m_1$, care va face ca întreg plaintextul să fie descoperit. 

\subsubsection{Atac de tip mesaje relaționale}
Când două plaintexte sunt criptate cu aceeași cheie publică $e$, este posibil să recuperăm plaintextele dacă exponentul public este mic iar relația liniară dintre plaintexte este cunoscută. Un atac inițial a fost făcut când exponentul public $e$ era $e=3$, de către  Franklin și Reiter \cite{franklyn} după care a fost preluată de Coppersmith \cite{copper3}, iar rezolvarea este dată de următoarea teoremă: \\
\textbf{Teprema 4.2} Fie $<N,e>$ o cheie publică RSA, cu $e=3$. Fie $m_1$ și $m_2$ două plaintexte astfel încât $m2=am_1b$. Date $a,b,c=m_1^{3} \ mod N,c2 = m_2^3 \ mod \ N$, atât $m_1$ cât și $m_2$ pot fi calculat în timpul $\log(N)$. Acest lucru este dovedid în următorul calcul:
$$ \frac{b(c_2 + 2a^3c_1 - b^3)}{a(c_2-a^3c_1+2b^3)} \ mod \ N$$ 
$$= \frac{m_1(3a^3bm_1^2+3a^2b^2m_1+3ab^3)}{3a^3m_{1}^{2}+3a^2b^2m_1+3ab^3} \ mod \ N = m_1$$ 
De îndată ce $m_1$ este cunoscut, este ușor să calculăm $m_2 = am_1 +b$

\subsubsection{Atac prin padare aleatoare}
Când două plaintexte sunt legate între ele printr-o relație liniară $m_2=am_1+b$, unde $b$ este necunoscut, tot este posibil să recuperăm plaintextul dacă b este suficient de mic. Acest atac a fost făcut pentru $e=3$ de către Coppersmith \cite{cooper2}, folosind următoare teoremă:\\
\textbf{Teorema 4.5} Fie $<N,e>$ e cheie RSA publică și $e=$. Fie $m_1$ și $m_2$ două plaintexte care satisfac relația $m_2=am_1+b$. Dat $c_1=m_1^3 \ mod \ N,c2=(m1+b)^3 \ mod \ N$, dacă $|b|<N^{1/9}$ atunci plaintexte $m_1$ și $m_2$ pot fi calculate în timp polinomial.

\subsection{Exponent de decriptare mic}
Dacă exponentul de decriptare (cel secret) este mic, pe lângă faptul că multe părți din mesaj nu se criptează, așa cum s-a arătat mai sus, există un algoritm rapid de găsire a lui $d$, cunoscând informațiile $e$ și $N$. Acest algoritm nu este eficient dacă $d$ este de același ordin de mărire cu $N$, deci dacă $e$ este mic, acesta fiind unul din motivele pentru care se alege în general $e$ un număr mic, pentru ca $d$ să fie cât mai mare.

\subsubsection{Atacul fracțiilor continue: Atacul Wiener}
Primul atac semnificativ asupra exponenților privați mici. Dată doar cheia publică RSA $<N,e>$, atacul factorizează modulul folosind doar informații obținute din convergența fracției continue $e/N$. Atacul Wiener folosește următoarea teoremă:
\textbf{Teorema} Fie $N=PQ$ modulul RSA cu $e$ cheia de criptare publică și $d$ cheia privată definită ca și $\lambda(N)$. Fie $k$ să fie un număr întreg care satisface următoarele:
$$ ed=1+k \lambda(N)$$
$$ g=cmmdc(P-1,Q-1) $$
$$g_0=\frac{g}{cmmdc(g,k)}$$
$$k_0=\frac{k}{cmmdc(k,g)}$$
Dacă $d$ satisface:
$$ d< \frac{PQ}{2(P+Q-q)g_0k_0} = \frac{N}{2(P+Q-1)g_0k_0}$$
Atunci $N$ poate fi factorizat în timpul $\log(N)$ \\
\textbf{Demonstrație}: folosim $N$ modulul RSA, unde $N=PQ$
$$ \lambda(N)=cmmmc(P-1,Q-1)=\frac{\phi(N)}{cmmdc(P-1,Q-1)}=\frac{PQ - (P+Q-1)}{g}$$
$$ = \frac{N - (P+Q-1)}{g}$$
Vom nota cu $s$ conținutul parantezii, deci rezultă:
$$ \lambda(N) = \frac{N-s}{g}$$
De aici rezultă că ecuația cheii va fi:
$$ed = 1 +k \lambda(N)= 1+ \frac{k* \phi(N)}{cmmdc(P-1,Q-1)} $$
Cunoaștem faptul că  $g_0 = \frac{g}{cmmdc(g,k)}$ și $k_0=\frac{k}{cmmdc(k,g)}$ de unde rezultă că $g=g_0 * cmmdc(g,k)$ și $k=k_0 * cmmdc(k,g)$, prin urmare $\frac{g}{k} = \frac{g_0}{k_0}$ de unde rezultă:
$$ 1+ \frac{k* \phi(N)}{cmmdc(P-1,Q-1)} = 1+ \frac{k (N-s)}{g} $$
$$ = 1+ \frac{k_0}{g_0} (N-s)$$
Dacă vom împărți ecuația $ed= 1+ \frac{k_0}{g_0} (N-s)$ la $dN$ vom obține următoarea relație:
$$ \frac{e}{N} = \left(  1+ \frac{k_0N - k_0s}{g_0}   \right) * \frac{1}{dN} $$
$$ \frac{e}{N} = \frac{1}{dN} + \frac{k_0}{g_0 d} +\frac{k_0s}{dNg_0}$$
De unde rezultă:
$$ \left |  \frac{e}{N} - \frac{k_0}{dg_0} \right| = \left| \frac{1}{dN} - \frac{k_0s}{dg_0N} \right| $$
De aici putem considera faptul că :
$$ \left| \frac{1}{dN} - \frac{k_0s}{dg_0N} \right| < \frac{k_0s}{dg_0N}$$
Folosind următoarea relație:
$$ d< \frac{N}{2(P+Q-1)g_0k_0}  $$
$$ d < \frac{N}{2sg_0k_0}$$
Din această relație putem ajunge la următoarea formulă:
$$ \frac{d}{N} < \frac{1}{2sg_0k_0} \Rightarrow \frac{k_0s}{N} < \frac{1}{2dg_0}$$
Înmulțind în ambele părți cu $\frac{1}{dg_0}$ obținem:
$$ \frac{k_0s}{dg_0N} < \frac{1}{2(dg_0)^2}$$
Din această relație, ajungem la concluzia că:
$$ \left| \frac{e}{N} - \frac{k_0}{dg_0} \right| < \frac{1}{2(dg_0)^2}$$
Știm din teorema fracțiilor continue, că $\frac{k_0}{dg_0}$ este una din convergențe din fracția continuă $\frac{e}{N}$. Dacă avem $c_i = \frac{a_i}{b_i}$ să fie convergența $i$ a lui $\frac{e}{N}$ atunci știm că $\frac{k_0}{dg_0} = \frac{a_j}{b_j}$ pentru un anumit $j$. \\
\textbf{Fracții continue} \\
Fie $a$ și $b$ numere naturale, $b \neq 0$, folosind algoritmul lui Euclid obținem:
$$a= q_1 *b+r_1, \ \ \ 0<r_1<b$$
$$b=q_2*r_1+r_2, \ \ \ 0<r_2<r_1$$
$$r_1= q_3*r_2+r_3, \ \ \ 0<r_3<r_2$$
$$ ...$$
$$ r_{k-2} = q_k *r_{k-1} +r_k , \ \ \ 0<r_k<r_{k-1}$$
$$ r_{k-1} = q_{k+1} * r_k$$
Frația $\frac{a}{b} $ poate fi scrisă după cum urmează:
$$ \frac{a}{b} = \frac{q_1b+r_1}{b} $$
$$ = q_1 + \frac{1}{\frac{b}{r_1}}$$
$$ = q_1 + \frac{1}{q_2 + \frac{1}{ \frac{b}{r_1}}} $$
$$ ...$$
$$ = q_1 + \frac{1}{q_2 + \frac{1}{\vdotswithin{q_k} q_k + \frac{1}{q_{k+1}}}} $$
Ultimul termen va fi referit ca fracția continuă asociată fracției $\frac{a}{b}$ și va finotat prin $[ q_1,q_2,...,q_{k+1}]$. Expresiile $[q_1,q_2,...,q_i]$ , $1 \leqslant i \leqslant k+1$, vor fi numite convergențele fracției continue $[q_1,q_2,...,q_{k+1}]$.\\
Considerăm numerele naturale $\alpha_{i}$ și $\beta_{i}$ date prinȘ
$$ \alpha_1 =q_1, \ \ \ \beta_1=1$$
$$ \alpha_2 = q_1 * q_2 + 1, \ \ \ \beta_2=q_2$$
$$ \alpha_i = q_i * \alpha_{i-1} + \alpha_{i-2}, \ \ \ \beta_i = q_i * \beta_{i-1} + \beta_{i-2}$$
Pentru orice $3 \leqslant i \leqslant k+1$ \\
Atunci are loc relația 
$$[q_1,q_2,...,q_i] = \frac{\alpha_i}{\beta_i}$$
$$(\alpha_i,\beta_i)=1$$
Pentru orice $1 \leqslant i \leqslant k+1$ \\
\textbf{Exemplu} Pentru $a=4$,$b=11$ obținem:\\
$$4=0*11+4$$
$$11=2*4+3$$
$$4=1*3+1$$
$$3=3*1$$
și $[0,2,1,3]= 0 + \frac{1}{2+\frac{1}{1+\frac{1}{3}}}$,$[0]=\frac{0}{1},[0,2]=\frac{1}{2}$ și $[0,2,1]=\frac{1}{3}$  \\
Acum să s-a înțeles conceptul de fracție continuă, vom încerca să scriem  ecuația $ed=1+k\lambda(N)$ sub o altă formă folosindu-ne de faptul că $\lambda(N)= \frac{N-s}{g}$
$$ ed = 1+k * \frac{N-s}{g} = 1 + \frac{kN-ks}{g}$$
$$ = 1+ \frac{k}{g}(N-s) = 1 + \frac{k}{g} (PQ - P - Q +1)$$
$$ = 1+\frac{k}{g}\phi(N)$$
Am demonstrat și faptul că $\frac{k_0}{g_0} = \frac{k}{g}$. Deci ecuația finală va fi:
$$ ed=1+\frac{k_0}{g_0}\phi(N)$$
De aici putem observa următorul lucru:
$$\phi(N) = (ed - 1 )\frac{g_0}{k_0}=ed \frac{g_0}{k_0} - \frac{g_0}{k_0}$$
$$ = e \left(  \frac{dg_0}{k_0}  \right) - \frac{g_0}{k_0} = e \left( \frac{b_j}{a_j}  \right) - \frac{g_0}{k_0}$$
Așadar, putem calcula $\phi(N)$ dacă cunoaștem convergența corectă $c+j$ și putem afla valorile $\frac{g_0}{k_0}$. Știm că putem calcula $\phi(N)$ în momentul în care putem să-l factorizăm pe $N$ deoarece $\phi(N)=(P-1)(Q-1)$ și $N=PQ$. \\
Pentru ușurința în calcul, vom presupune că $g=2$ și $k$ este un număr suficient de mic, deci $\frac{k_0}{g_0} \approx k$, atunci $ed = 1+k\phi(N)$ de unde rezultă:
$$ ed-k\phi(N)=1$$
$$ \frac{e}{\phi(N)} - \frac{k}{d} = \frac{1}{d\phi(N)}$$
$$ \frac{e}{N} \approx \frac{k}{d} $$ 
Deoarece $PQ - (P+Q)+1 \approx N$
Pentru găsirea lui $\frac{e}{N}$ trebuie să găsim fracția $\frac{k}{d}$. Trebuie să ținem cont de următoare observații:
\begin{enumerate}
\item Deoarece $ed \equiv 1 \ mod \ \phi(N)$ și $\phi(N)$ va fi un număr par, $d$ trebuie să fie impar. Deci dacă $d$ este par, vom continua la următoarea convergență.

\item Deoarece $\phi(N)$ este un număr întreg, vom verifica  $\frac{ed -1}{k}$. Dacă este un număr întreg, vom trece la următoarea convergență.

\end{enumerate}
\textbf{Ecuația pătratică} \\
Din
$$ \phi(N)=N-(P+Q)+1$$
$$ P+Q = N - \phi(N) +1$$
Considerăm ecuația de gradul 2 $(x-P)(x-Q)$ cu rădăcinile $P$ și $Q$. Atunci vom avea:
$$(x-P)(x-Q)=0$$
$$x^2 - (P+Q)x + PQ = 0$$
$$x^2 - (N- \phi(N)+1)x + N =0$$
Dacă valuarea lui $\phi(N)$ este corectă, atunci rădăcinile ecuației de gradul 2 vor fi numere întregi, numerele fiind chiar factorii lui $N$. \\

\textbf{Exemplu} vom avea modului RSA $N=64741$ și exponentul public $e=42667$. Exponentul de decriptare fiind $d$.\\
Trebuie să ne amintim faptul că $ \frac{e}{N} \approx \frac{k}{d}$, deci va trebuie să găsim aproximarea fracției $\frac{e}{N} = \frac{42667}{64741}$. Vom folosi algoritmul lui Euclid pentru a găsi convergențele succesive. \\
$$\frac{42667}{64741}= 0 \ rest \ 42667 \Rightarrow \frac{k}{d} \approx 0 $$
Dar $k=0, d=1$ clar nu vor funcționa pentru decriptare, deci vom trece la următoarea convergență.
$$ \frac{64741}{42667} = 1 \ rest \ 22074 \Rightarrow \frac{k}{d} \approx 0 + \frac{1}{1}$$
Din nou $k=1,d=1$ nu va funcționa pentru decriptare, deci vom trece din nou la următoarea convergență.
$$ \frac{42667}{22074} = 1 \ rest \ 20593 \Rightarrow \frac{k}{d} \approx 0 + \frac{1}{1+\frac{1}{1}} = \frac{1}{2}$$ 
Acum avem $k=1,d=2$ dar am menționat mai sus că $d$ trebuie să fie un număr impar, deci vom trece la următoarea convergență
$$ \frac{22074}{20593} = 1 \ rest \ 1481 \Rightarrow \frac{k}{d} \approx 0 + \frac{1}{1 + \frac{1}{1+\frac{1}{1}}} = \frac{2}{3} $$ 
De aici ne rezultă $k=2,d=3$, acesta fiind un rezultat posibil. Acum trebuie să verificăm dacă $\phi(N)$ este un număr întreg:
$$\phi(N)=\frac{ed-1}{k}=\frac{42667 * 3 -1}{2}=64000$$
Am trecut de ambele condiții, acum trebuie să vedem dacă ecuația de gradul 2 $x^2 - (N- \phi(N) +1)x +N=0$ are soluții întregi.
$$x^2 - (N- \phi(N)+1)x+N=0$$
$$x^2 - (64741 - 64000 +1)x + 64741=0$$
$$x^2 - 742x + 64741=0$$
$$ \Delta = b^2 - 4ac = 742^2 + 4*64741 = 550564 - 258964 = 291600 = 540^{2} $$
$$x_1 = \frac{-b + \sqrt{\Delta}}{2a} = \frac{742 + 540}{2} = 641$$ 
$$x_2 = \frac{-b - \sqrt{\Delta}}{2a} = \frac{742 - 540}{2} = 101$$

Cum $641 * 101 = 64741$, înseamnă că l-am factorizat corect pe $N$, deci $d=3$
\subsubsection{Apărarea împotriva atacului Wiener}
Este destul de clar că atunci când implementăm RSA, vom dori să evităm acest atac. Avem următorii parametri: \\
\begin{itemize}
\item Alegem $P,Q$ cu $N=PQ$

\item Găsim $ed$ astfel încât $ed \equiv 1 \ mod \ \phi(N)$

\end{itemize}
Putem dovedi că, dacă $q<p \leqslant 2q$ și $ d \leqslant \frac{1}{3} \sqrt[4]{N}$ atacul Wiener va reuși. \\
Astea înseamnă că noi trebuie să alegem $d > \frac{1}{3} \sqrt[4]{N}$. Și așa, există o șansă ca atacul Wiener să reușească.

\subsubsection{Numere prime parțial cunoscute}
La acest atac, trebuie să ne bazăm pe faptul că $N$ este o aproximare a lui $\phi(N)$. În particular, atacurile depind de inecuația $ | N-\phi(N)|=|s| < 3N^{1/2}$. Pentru îmbunătățirea acestui atac, va trebui să găsim o aproximare mai bună pentru $\phi(N)$. \\
Când măcar unul din cele două numere prime ale modulului RSA, are cel mai semnificativ bit cunoscut, atunci noi putem să formăm o aproximare mai bună pentru $\phi(N)$. Fie $P^{'}$ o aproximare pentru $P$ care satisface următoarea relație:
$$ |P - P^{'}| < N^{\gamma} $$
cu $ \frac{1}{4} < \gamma \leqslant \frac{1}{2} $. Cu $P^{'} $ cunoscut, îl putem calcula foarte ușor și pe $ Q^{'} $
$$ |Q - Q^{'} | = \left| \frac{N}{P} - \frac{N}{P^{'}} \right| = \left|\frac{N(P-P^{'})}{PP^{'}}\right| < 5 N^{\gamma} $$ 

Folosind aceste relații, vom putea calcula și o aproximare a lui $N$ notată $N^{'}$ care corespune următoarei formule:
$$ N^{'}= N-P^{'} - Q^{'} +1 $$
Iar de aici putem scoate o aproximare și pentru $s^{'}$
$$ \left| \phi(N) - N^{'} \right| = | (P-1)(Q-1) - (N-P^{'} - Q^{'} +1) | $$
$$ = |PQ - P - Q + 1 - N + P^{'} + Q^{'} -1 | $$
$$|P-P^{'} + Q - Q^{'}| $$
Știm că $ |P-P^{'}| < N^{\gamma} | $ și $|Q-Q^{'}| < 4N^{\gamma}$ rezultă
$$ | P-P^{'} + Q -Q^{'}| < 5N^{\gamma} $$ 
Având toate aceste date, ecuația finală va fi:
$$ ed=1+k\phi(N) =1 + k(N^{'} -s^{'})$$
Folosind această relația, putem dezvolta următorul atac de tip exponent de decriptare mic. În realizarea acestui atac, vom folosi următoarea teoremă: \\
\textbf{Teoremă} fie $N=PQ$ modulul RSA, $e$ exponentul de criptare și $d$ exponentul de decriptare. Fie $k$ un număr întreg care satisface relația $1 + k \lambda(N),g=cmmdc(P-1,Q-1),g_0=\frac{g}{cmmdc(g,k)}$ și $k_0=\frac{k}{cmmdc(k,g)}$. Folosind $P^{'}$ cu proprietatea $|P - P^{'}|<N^{\gamma}$, exponentul de decriptare are următoarea proprietate:
$$d<\frac{N^{'}}{2s^{'}g_0k_0}$$
Totuși, această primă relație este posibil să nu fie suficientă pentru a putea dezvolta atacul, și vom avea nevoie de o inecuația care să-l conțină și pe $N^{\gamma}$.
$$ N^{'} = N - P^{'} - Q^{'} + 1 \Rightarrow N^{'}  < N$$
$$ s^{'} = |P-P^{'} + Q - Q^{'}| < 5N^{\gamma}$$
Împărțind aceste două relații vom obține:
$$\frac{N^{'}}{s^{'}} < \frac{N}{5N^{\gamma}} \Rightarrow \frac{N^{'}}{s^{'}} < \frac{N^{1-\gamma}}{5} $$
Înmulțind îm ambele părțti cu $\frac{1}{2g_0k_0}$ obținem
$$ \frac{N^{'}}{2s^{'}g_0k_0} < \frac{N^{1-\gamma}}{10g_0k_0}$$
Așadar,am aflat că 
$$ d<\frac{N^{'}}{2s^{'}g_0k_0}<\frac{N^{1-\gamma}}{10g_0k_0}$$
Folosind această inecuație, îl vom putea factoriza pe $N$ în timp polinomial.
De asemenea, dacă vom considera un parametru $\deg$ astfel încât $d=N^{\delta}$, atunci atacul se va simplifica la 
\[
\delta \leqslant
\left\{ 
\begin{array}{c}
\frac{1}{4} - \frac{\alpha}{2} - \epsilon, \ \ \ \lambda=1/2  \\
1 - \frac{\alpha}{2} - \frac{\lambda}{2} - \epsilon, \ \ \ \lambda<1/2  
\end{array}
\right. 
\]
Pentru un exponent arbitrat fixat va rezulta:
\[
\delta \leqslant
\left\{ 
\begin{array}{c}
\frac{3}{4} -  \epsilon, \ \ \ \lambda=1/2 , \ \alpha=1  \\
\frac{1}{2} - \frac{\lambda}{2} - \epsilon, \ \ \ \lambda<1/2, \ \alpha=1 
\end{array}
\right. 
\]
\\
Toate atacurile de tip "latice-bassed" bazate pe exponenți de decriptare mici, au fost îmbunătățite de către Sarkar,Maitra și Sarka \cite{sarkar}. Pentru a generaliza atacul Blomer și May inpsirat din \cite{sarkar}, vom considera: \\
Pentru $\forall \epsilon > 0, \exists n_0$ astfel încât $n>n_0$ unde $n$ este lungimea în biți a lui $N$. Fie $N=PQ$ modulul RSA cu $e$ cheia publică și $d=N^{\gamma}$ cheia privată, ce corespunde modulului $\phi(N)$. Dată cheia publică $<N,e>$ și $\lambda$ cu $\frac{1}{4}<\lambda\leqslant \frac{1}{2}$ și 
$$ \delta \leqslant \frac{2}{5} - \frac{6}{5}\lambda + \frac{2}{5} \sqrt{4\lambda^{2}- \lambda +1} - \epsilon $$,
atunci modulul $N$ poate fi calculat în timp polinomial. \\
O altă formă, este dată de următoarea teoremă \\
\textbf{Teoremă} $\forall \epsilon > 0, \exists n >n_0$. Fie $N=PQ$ modulul RSA cu $e$ exponentul public și $d=N^{\delta}$ exponentul privat definitit modulo $\phi(N)$. Date fiind cheia publică $<N,e>$ și $\lambda$ cu $\frac{1}{4} < \lambda \leqslant \frac{1}{2} $ satisfac următoarea relație
$$ 1- 2\lambda < \delta \leqslant 1 - \sqrt{\lambda}-\epsilon$$
atunci putem găsi modulul RSA în timp polinomial.
\section{Criptanaliză pe variante RSA}
\subsection{CRT-RSA}
Puterea computațională necesară decriptării RSA-ului poate fi redusă exploatțnd factorizarea modulului $N$. Fie $<N,e>$ cheia publică RSA și $<d,P,Q>$ cheia privată unde exponenții sunt definiți modulo $\lambda(N)$. Pentru un criptotext $c=m^e \ mod \ N$ decriptarea standard se obține făcând calculul
$$ m=c^d \ mod \ N$$
Acest calcul fiid o singură exponențiere pe $n$ biți. Totuși, plaintextul poate fi obținut prin decriptări parțiale, una modulo $P$ și alta modulo $Q$. Folosind teorema Chineză a resturilor  va trebui să calculăm:
$$ m_P = c^d \ mod \ P$$
$$ m_Q = c^d \ mod \ Q$$
Deoarece $P$ și $Q$ sunt numere prime (înseamnă că sunt și relativ prime), combințnd aceste două ecuații folosind teorema Chineză a resturilor, vom putea obține rezultatul. Folosind algoritmul lui Garner \cite{garner}, atunci plaintextul se calculează astfel:
$$ m=m_P+P((m_Q-m_P)p^{-1} \ mod \ Q)$$
Totuși, când exponentul de decriptare este mai mare decțât $\sqrt{N}$,un exponent redus poate fi folosit. Fie $d_P$ și $d_Q$ astfel încât:
$$ d_P = d \ mod \ (P-1) $$
$$ d_Q = d \ mod \ (Q-1) $$
De unde rezultă:
$$ m_P = c^{d_P} \ mod \ P $$
$$ m_Q = c^{d_Q} \ mod \ Q $$
Îi vom numi pe $ d_P $ și $d_Q$ exponenții CRT. Din ecuațiile de mai sus și din faptul că $ed = 1+ k\phi(N)$ următoarele:
$$ ed_P \equiv 1 \ mod \ (P-1)$$
$$ ed_Q \equiv 1 \ mod \ (Q-1)$$
De asemenea, $\exists k_P$ și $k_Q$ astfel încât:
$$ ed_P = 1 + k_P(P-1)$$
$$ ed_Q = 1+ k_Q(Q-1)$$
\subsubsection{Spargerea CRT-RSA}
Calculând exponenții CRT este suficient pentru a sparge această variantă de RSA. Dacă avem ambții exponenți $d_P$ și $d_Q$ putem obține următoarea relație:
$$ed_P = 1 + k_P(P-1) \Rightarrow ed_P -1 = k_P(P-1)$$
$$ed_Q = 1 + k_Q(Q-1) \Rightarrow ed_Q -1 =k_Q(Q-1)$$
Înmulțind aceste două relații obținem:
$$ (ed_P -1 ) (ed_Q -1) = [k_P(P-1)][k_Q(Q-1)] \Rightarrow $$
$$ \Rightarrow e^2e_Pd_Q - ed_P - ed_Q +1 = k_P(P-1)k_Q(Q-1) \Rightarrow$$
$$ \Rightarrow e(ed_Pd_Q - d_P -d_Q)+1 = k_P(P-1)k_Q(Q-1)$$
Unde, fiecare membru din partea stângă este cunoscut.  Așadar, putem calcula un multiplu de $\phi(N)$ ce ne va permite într-un mod probabilistic să factorizăm modulul folosind Miller \cite{miller}.
Cunoscând doar un singur exponent CRT, existp totuși o șansă ca modulul $N$ să poate fi factorizat.\\
Să presupunem că $d_P$ este termenul cunoscut. Dacă $d$ cheia privată este mai mică decât fiecare număr prim, astfel încât $d = d_P = d_Q$ atunci $ed_P-1$ este un multiplu de $\lambda(N)$ și modulul poate fi factorizat folosind Miller \cite{miller}. Dacă exponentul privat $d$ este mai mare decât fiecare dintre numerele prime, atunci vom obsera folosind $ed_P = 1 + k_P(P-1)$ că $m^{ed_P} \equiv m \ mod \ P$, pentru orice plaintext $m \in \mathbb{Z}_{P}^{*}$, atunci:
$$ m^{ed_P} - m = cp$$
unde $c$ este un număr întreg. Fie $M=(m^{ed_P} - m) \ mod \ N$. Când $c$ nu este un multiplu al numărului prim $Q$ , factorizarea modulului este dată de $cmmdc(M,N)=P$. Atunci când $c$ este un multiplu al lui $q$ atunci $m^{ed_P} \equiv m \ mod \ N$. De aici rezulltă că $\forall m \in \mathbb{Z}_{P}^{*}$, atunci modulul $N$ poate fi factorizat, deoarece $d_P$ este un exponent valid de decriptare și $ed_P-1$ dezvăluie un multiplu al lui $\lambda(N)$.
\subsubsection{Reconstruirea cheii folosind erori aleatoare}
Aceasta este o altă modalitate pentru reconstrucția cheii atunci când se folosește CRT-RSA.\\
Este menționat în \cite{95}, că atacul poate fi îmbunătățit folosind mai multe informații despre cheia privată. Întradevăr, există un atac îmbunătățit realizat de Heninger și Shacham \cite{heninger} pentru exponenți publici mici, folosesc aproximări pentru fiecare $P,Q,d,d_P,d_Q$, din CRT-RSA și exploatează următoarele 4 ecuații:
$$ N=PQ $$
$$ ed=k(N-P-Q+1)+1$$
$$ ed_P=k_P(P-1)+1$$
$$ ed_Q=k_Q(Q-1)+1$$
care conțin 8 necunoscute. Deoarece exponentul public este mic, $2^10+1$ spre exemplu, constantele $k$,$k_P$ și $k_Q$ poate fi ușor determinate ceea ce reduce numărul de necunoscute la 5.\\
Pentru determinarea lui $k$ 




\chapter{Variante și Optimizări RSA}
\section{RSA varianta distribuită (Schema lui Shoup)}
\subsection{Introducere}
Varianta partajată a RSA (schemă prin semnături) prezintă câteva aspecte foarte interesante. În primul rând, este securizată și robustă deoarece problema criptanalizei este foarte grea. Apoi, partajarea, generarea semnăturii și verificarea sunt non interactive și în final, dimensiunea unei semnături partajate este legată de o constantă înmulțită cu dimensiunea modulului RSA. \\
Când un mesaj trebuie să fie semnat de măcar $ t+1 $ server unde $ 2t+1 \leqslant l $, un server special numit combinator, direcționează mesajul $m$ sau $x$, unde $x=H(x)$ către toate serverele, apoi fiecare server calculează semnătura cu o dovadă de corectitudine, apoi combinatorul selectează un subgrup de $t+1$ servere și le combină. \\
Folosind distributivitatea aditivă, $d=\sum_{i=1}^{l} d_i \ mod \ \phi(N)$, combinatorul poate alcula ușor semnăturile $S$, $s_i=x^{d_i} \ mod \ N$, unde $x=H(m)$, este mesajul semnat folosind formula:
$$ S= \prod_{i=1}^{l} S_i = \prod_{i=1}^{l} x^{d_i} = x^{\sum_{i}^{l} d_i} = x^d \ mod \ N $$
Principalul dezavantaj al acestor tehnici îl reprezintă mărimea cheilor, din cauza necesității diferitelor partajări și a tehnicilor de reconstruire a semnăturilor. Ulterior, Shoup a propus prima schemă bazată pe partajarea polinomială (schema Desmedt și Frankel \cite{desmet}). Protocolul trebuie să revină de $t$ ori pentru a putea înlătura serverele rele, semnătura depinzând e un subgrup de $t+1$ servere. \\
Fie $\delta =l!$. Partajarea lui $d$ este în așa fel încât $\delta | d_i$ și $d_i =f(i)$ unde $f$ este un polinom de grad $t$ și cu termenul constant $d$. \\
Fie $S$ mulțimea a $t+1$ servere, atunci coeficientul Lagrange va fi: 
$$ \lambda_{i,j}^{'S} = \prod_{j^{'} \in S \setminus j}^{} \frac{i-j^{'}}{j-j^{'}}   $$
De unde rezultă:
$$ d= \sum_{i \in S}^{} \lambda_{0,i}^{'S} d_i \ mod \ \phi(N)$$
O problemă majoră o reprezint faptul că $\lambda_{i,j}^{'}$ nu poate fi calculat în $\mathbb{Z}_{\phi(N)}$ deoarece $\phi(N)$ poate fi par. Apoi combinatorul trebuie să calculeze:
$$s=\prod_{i \in S}^{} S_{i}^{\lambda_{0,i}^{'S} d_i}$$
$$ = S^{\sum_{i \in S}^{}\lambda_{0,i}^{'S} d_i} = S^d \ mod \ N$$.
Cum numerele din mulțimea $ \lambda_{i,j}^{'S}$ nu sunt numere întregi, combinatorul nu poate calcula rădăcina modulo a unui număr compus. Ideea esențială este să spunem că $\delta \times \lambda_{i,j}^{'S}$ sunt numere întregi. Atunci putem spune că 
$$l_{0,i}^{S} = \delta \times \lambda_{i,j}^{'S} \ , \ i \in \mathbb{Z} $$
Și:
$$ S^{'} = x^{l_{0,i}^{S} \times * d_i } \ mod \ N   $$
Combinatorul va calcula:
$$S = \prod_{i \in S}^{} S_{i}^{'} = \prod_{i \in S}^{} x^{l_{0,i}^{S} \times d_i    } $$
$$ = \prod_{i \in S}^{}  x^{\delta \times \lambda_{i,j}^{'S} \times d_i} = \prod_{i \in S}^{} 
x^{\lambda_{0,j}^{'S} d_i} = x^d \ mod \ N  $$

Dacă semnătura nu este bună, atunci combinatorul înlătură serverele rele. După $t$ iterații, toate serverele rele sunt înlăturate din setul $S$ iar semnăturile rămase vor fi corecte. Totuși, nici această redefinire a subgrupului nu părea să fie foarte bună, și Shoup a propus o nouă tehnică. \\
Problema a fost rezolvată folosind o lemă cunoscută pentru a extrage $e$-rădăcina lui $w$ modulo un număr compus dintr-o $e$-rădăcină a unei puteri $w$ cunoscute fără a folosi secrete. Soluția a fost să multiplicăm coeficienții Lagrange cu $\delta$ ca aceștia să devină întregi. 
$$ \lambda_{i,j}^{'S} = \delta \times \lambda_{i,j \in \mathbb{Z}}^{'S} $$
Și:
$$ \delta d = \sum_{i \in S}^{} \lambda_{0,i}^{S} d_i $$
Fie $ s_i = x^{d_i} $, combinatorul care calculează semnătura și schimbarea grupului (folosind noua formulă Lagrange pentru cele $t+1$ servere). Se calculează ecuația folosind $\lambda_{i,j}^{S} $ și se obține:
$$S^{\delta} = \prod_{i \in S}^{} S_{i}^{\lambda_{0,i}^{S} = x^{\delta d} \ mod \ N}$$
În final, combinatorul calculează rădăcina lui $x^d$.

\subsection{Dovada robusteții și folosirea numerelor prime sigure}
Robustețea înseamnă faptul că serverele corupte nu le pot împiedica pe cele necorupte să-și realizeze semnătura. \\
În dovada corectitudinii serverele trebuie să dovedească că ridică $x$ la puterea $d_i$. Serverul $i$ deține cheia de verificare
$$ v_i = \log_{x} S_i = d_i \ mod \ \phi(N)$$
Problemele sunt: $\mathbb{Z}_{N}^{*}$ nu este un grup ciclic,  generatorul $V$ nu există și elementele de ordin maximal sunt greu de găsit. Dacă vom folosi numere prime sigure, atunci $\mathbb{Z}_{N}^{*}$ este un grup ciclic, iar generatoarele sunt ușor de găsit. \\
Pentru a nu crea neclarități, este bine să descriem totuși ce este acela un grup, mai precis un grup ciclic: 
\subsubsection{Grupuri}
Un grup este o structură algebrică ce constă dintr-o mulțime pe care este definită o lege de compoziție internă (acesta combină două elemente ale unei mulțimi și formează un al treilea element tot din aceeași mulțime). Pentru a fi un grup, mulțimea și operația trebuie să satisfacă o serie de axiome:
\begin{enumerate}
\item Axioma închiderii: \\
$\forall x,  y \in G$  , și rezultatul operației $x \circ y \in G$

\item Axioma asociativității: \\
$\forall x,y,z \in G, (x \circ y) \circ z = x \circ (y \circ z)$

\item Axioma elementului neutru: \\
$\exists e \in G$, astfel încât $e \circ x = x \circ e = x, \ \forall x \in G$

\item Axioma elementelor simetrice: \\
$\forall x \in G, \exists y \in G$ cu proprietatea că $x \circ y = y \circ x = e$

\item Axioma comutativității:
$\forall x,y \in G, x \circ y = y \circ x$ \\
atunci grupul $(G,\circ )$ se numește grup comutativ sau abelian



\end{enumerate}
\textbf{Un grup ciclic} este un grup ale cărui elemente sunt puteri (când operația de grup este considerată a fi de natură aditivă, se preferă termenul de multipli) ai unui element $a$. 

\subsection{Problema}
Numerele prime sigure sunt folosite în general de chei pentru a dovedi faptul că schema de partajare a secretelor (Shamir) este sigură în inelul $\mathbb{Z}_M$, și nu într-un corp finit. Robustețea ne garantează faptul că dacă un jucător malițios trimite semnături false, scema tot va genera corect S. \\
Spre exemplu: combinatorul primește de la servere și trebuie să genereze semnăturile corecte. O cale de a face acest lucru este să alegem aleator $t+1$ semnături, să generăm posibilele semnături $S^{'}$ și să testăm dacă $S^{'}$ este valid. Dacă $S^{'}$ trece de protocolul de verificare, atunci semnătura corectă a fost găsită, dacă nu, combinatorul trebuie să testeze alte $t+1$ semnături. Combinatorul nu știe care sunt semnăturile false iar din această cauză, acesta poate ajunge la un număr exponențial de încercări. Așadar, este necesar să divizăm într-un mod eficient.


\subsection{Modele de securitate}
\subsubsection{Rețeaua}
Grupul de $l$ servere conectate la un mediu prin broadcast, iar mesajele trimise către canalul de comunicare ajung la fiecare entitate.
\subsubsection{Adversarul}
Adversarii pot corupe servere în orice moment prin verificarea memoriei serverelor corupte(adversar pasiv) și/sau pot modifica comportamentul acestora(adversari activi). Adversarii decid pe cine să corupă la startul protocolului (adversari statici). Putem asuma și ca adversarii nu vor corupe mai mult de $t$ servere din $l$, unde $l \geqslant 2t+1$.
\subsubsection{Definiții formale}
O schemă RSA de semnături folosește următoarele componente:
\begin{enumerate}
\item Un algoritm de generare de chei care primește ca input parametrii de securitate $N$, numărul $k$ de elemente care trebuie să genereze $Q_N$, numărul de $l$ servere care trebuie să semneze, parametrul $t$ și un string random $w$. Are ca și output o cheie publică $<N,e>$, cu cheile private $d_1,...,d_t$ cunoscute doar de servere corecte pentru fiecare $u \in [1,k]$ o listă $v_u,v_{u,1},...v{u,t}=v_{u}^{d_i} \ mod \ N$ verificări de chei. 
\item Un algoritm de partajare de semnături primește ca input o cheie publică $<N,e>$, un index $ 1\leqslant i \leqslant l$, cheia privată $d_i$, și un mesaj $m$; are ca output o semnătură $s_i = x^{d_i} \ mod \ N$ unde $x=H(m)$ și $H()$ este o funcție de hash și padare, și dovada validității este:
$$ validity \ proof_i \ (for \ all \ u \in [1,k], \log_{v_u} v_{u,i}=\log_x S_i)$$
\item Un algoritm combinat de verificare primește ca input o cheie publică $<N,e>$, un mesaj $m$, o listă $s_1,...,s_l$ de semnături partajate, pentru fiecare $u \in [1,k]$ lista $v_u,v_{u,1},...,v_{u,l}$ de chei de verificare și o listă $proof_1,...,proof_l$ de validări, și ca output o semnătură sau fail.
\item Un algoritm de verificare primește ca input o cheie publică $<N,e>$, un mesaj $m$, o semnătură $S$ și are ca output un bit $b$ indicând dacă semnătura este corectă sau nu.
\end{enumerate}
\subsubsection{Jucătorul și adversarul}
Jocul nostru include următorii jucători: un combinator, un set $l$ de severe $P_i$, un adversar, userii care cer semnături.\\
Considerăm următorul scenariu: \\
\begin{enumerate}
\item La faza de inițializare, serverele folosesc algoritmul distribuit de generare de chei pentru crearea cheilor private, publice și a cheilor de verificare. Cheia publică $<N,e>$ și cheile de verificare $v_{u}^{'}S$ și $v_{u,i}^{'}S$ sunt publicate și fiecare server obține partajarea $d_i$ a cheii secrete $d$.
\item Pentru a semna un mesaj $m$, combinatorul trimite mai departe $m$ către servere. Folosind cheia privată $d_i$ și cheile de verificare $v_u,v_{u,1}$ pentru $u \in [1,k]$ pentru fiecare server rulează algoritmul de partajare de semnături și are ca output o semnătură partajată $S_i$ împreună cu o dovadă de validitate și o dovadă de validitate $proof_i$. În final, combinatorul utilizează algoritmul de combinare de generare de semnături, și scoate câte semnături partajate sunt valabile și valide.
\end{enumerate}
\subsubsection{Proprietăți}
După cum am mai menționat, robustețea garantează faptul că dacă avem un număr $t$ de jucători malițioși care trimit semnături false, schema tot va returna o semnătură corectă. Această proprietate este folosită doar în prezența adversarilor activi.\\
Proprietatea care asigură fapul că nu poate fi falsificat , spune că pentru orice subset de $t+1$ jucători pot genera o semnătură $S$, dar nu permite generarea a mai puin de $t$ jucători. Această proprietate exprimă securitatea unei scheme de securitate și este folositoare în prezența atacurilor adversarilor pasivi.
\subsubsection{Generarea cheii și protocolul de semnare}
În această secțiune, vom descrie noțiunile de securitate pentru generarea de chei și protocolul pentru semnături. Am arătat că informațiile arătate în timpul generărilor de chei și semnării nu eliberează informații secrete adversarilor.
\begin{itemize}
\item Jocul pentru generarea de chei: \\
Corectitudinea pentru generarea cheilor necesită ca probabilitatea cheilor secrete $d, P, Q$ și cheilor publice $<N,e>$ să fie uniform distribuite către adversari \\ 
Dacă $\exists$ un adversar $A$ care corupe cel mult $t$ servere la începutul jocului, atunci el nu poate obține informația ținută de jucătorii necorupți

\item Jocul pentru protocolul de semnare: \\
Secretul semnării înseamnă că dacă $\exists$ un adversar $A$ care corupe cel mult $t$ servere la începutul jocului chiar dacă el poate obține informații, el nu poate forța o semnătură pe un nou mesaj.
\end{itemize}


\subsection{Un nou mod de a genera modulul RSA (schema Boneh-Franklin \cite{boneh})}
Obiectul este să generăm moduli RSA astfel încât grupul este ciclic, iar ordinul acestui grup nu are factori primi mici.
\subsubsection{Un nou modul distribuit}
\begin{enumerate}

\item La primul pas,fiecare server generază aleator două valori $p_i$ și $q_i$ în intervalul $ \left[ [2^{(n-1)/2}], [\frac{2^{n/2}-1}{l}] \right]$ unde $n$ este dimensiunea în biți. Apoi vom folosi un algoritm pentru a renunța la $p_1,...p_l$ și $q_1,...,q_l$ care au factori primi mici, și dacă $p_1+...+p_{l-1}$ sau $q_1+...,+q_{l-1}$ au factori primi mici. Serverul verifică dacă $cmmdc(P-1,4P)=2$ și $cmmdc(4P,Q-1)=2$ unde $P = \prod_{2 <p_i < B} p_i$

\item Protocolul este rulat pentru a calcula produsul $N$ al lui $p_1+...+p_l$ și $q_1+...+q_l$. Se calculează și produsul lui $\phi(N)=(P-1)(Q-1)$ și $cmmdc(\phi(N),N-1)=1$

\item Trebuie să folosim și un test de primalitate
\end{enumerate}
\subsubsection{Calculul cmmdc a unei valori publice și a unei valori secrete partajate}
Tehnica de bază constă prin observarea faptului că $cmmdc(e,\phi)=cmmdc(e,\phi + Re)$ unde $R$ este un număr întreg mare folosit pentru a masca valoarea secretului partajat:
$$\phi=\phi_1+...+\phi _l$$.
Serverul $i$ generează aleator un întreg $r_i \in [0 ... 2^{n+k^{'}}]$, unde $k^{'}$ este un parametru de securitate, calculează:
$$ c = \sum_{i}^{} c_i = \phi + eR$$
Dacă setăm $R=\sum_i r_i$. Această valuare poate fi cunoscută public apoi, toate serverele vor calcula $cmmdc(e,\phi)=1$. Apoi, este ușor să arătăm că dacă vom înlocui $c$ cu $\phi + eR$, vom obține $e(u + R_v) + \phi v = 1$. Prin urmare, $u + R_v \ mod \ \phi$ este inversul modular al lui $e \ mod \ \phi$. În acest caz, dacă notăm cu $d$ inversul $e \ mod \ \phi$, fiecare server asignează inversul lui $d$ către $d_i = vr_i$ și primul server lui $d_1= vr_1$.
\subsubsection{Îmbunătățirea generării numerelor fără factori mici}
\begin{enumerate}
\item Fiecare server generează aleator un număr întreg $a_i$ în intervalul $[1,P]$ în așa fel încât $a_i$ este relativ prim lui $P$. Deoarece $a_i$ este un număr întreg aleator relativ prim cu P, atunci $a=a_1,...,a_l \ mod \ P$ este de asemenea relativ prim cu P.

\item Serverul rulează un protocl pentrua converti $a$ la $a=b_1+...+b_l$.

\item Fiecare serve generează aleator un număr random:
$$r_i \in \left[  [ \frac{\sqrt{2}* 2^{\frac{n}{2} -1} }{P}   ], [\frac{2^{\frac{n}{2}-1}}{p^l}]      \right] $$
Și:
$$ p_i=r_i P + b_i$$
$p = \sum p_i \equiv a \ mod \ P$ și prin urmare $p$nu este divizibil de nici un număr prim mai mic decât $B$. Putem nota $p=BR +a$ unde $R=\sum_{i} r_i$. Acest lucru funcționează doar dacă $P<p$. Pentru a arăta asta și că $p^{'} = \frac{p-1}{2}$ nu are factori primi în afară de B, atunci trebuie să verificăm că $cmmdc(p-1,P)=cmmdc(2p^{'},P)=1$ și $cmmdc(p-1,4P)=2$ ca să testăm puterea lui 2. Dacă notăm $P^{'}=4P$, putem face un singur test $cmmdc(p-1,P^{'})=2$\\
În final, protocolul care transformă partajarea multiplicativă a lui $a$ într-o partajare aditivă, poate fi făcută robustă. Această transformare apelează de $l$ ori protocolul. La început $b_{i,0}=0$ pentru toți $i \in {0,...,l}$. Apoi, pentru fiecare $i=1$ până la $l$, $u_i=a_i$ și $i_j=0$ pentru $\forall j \neq u$ iar protocolul execută: 
$$(b_{1,i-1}+...+b_{l,i-1}) \times a_i = (b_{1,i-1}+...+b_{l,i-1})(u_1+...+u_l)=b_{1,i}+...+b_{l,i}$$
\end{enumerate}
\subsubsection{Generarea lui $N$ întrucât $Q_N$ este ciclic}
Aici vom arăta cum trebuie generat $N$ astfel încât $Q_N$ să fie ciclic. Pentru a garanta această proprietate trebuie să ne folosim de faptul că prodosul a două grupuri ciclice care sunt coprime este un grup ciclic. Trebuie să verificăm totuși că $P^{'}$ și $Q^{'}$ sunt coprime. Întâi trebuie demonstrată următoarea lemă: \\
Lema 1: $N=PQ$, $cmmdc(P-1,Q-1)|c,,dc(N-1,\phi(N)$ și pătratul liber (un pătrat liber este un număr care nu este divizibil de nici un număr care este pătrat perfect) al lui $cmmdc(N-1,\phi(N))$ divide $(P-1),(Q-1)$. Dacă $cmmdc(N-1,\phi(N))=2$ atunci $cmmdc(P-1,Q-1)=2$ \\
Demonstrație: Dacă $cmmdc(N-1,\phi(N))=2$ atunci $cmmdc(P-1,Q-1)|cmmdc(N-1,\phi(N)), cmmdc(P-1,Q-1)=2$. Deoarece $cmmdc(P-1,Q-1) \neq 1$.\\
\textbf{Teorema}: Generarea cheilor folosind Boneh-Franklin și $cmmdc$ ne ajută să generă, chei RSA în așa fel încât grupul $Q_N$ este ciclic de ordin $M=P^{'}Q^{'}$, unde $N=PQ$, $P=2P^{'}+1$,$Q=2Q^{'}+1$ și nici $P^{'}$ șau $Q^{'}$ au factori primi mai mici decât B. Numărul de iterații ale acestui protocl are o medie de $ 4 \times e^{\lambda} \ln(B)$ \\
Demonstrație: Ne asumăm faptul că avem un modul RSA în care $P-1$ și $Q-1$ au divizoriiprimi mai mari decât B, aceștia nu au divizori comuni, $cmmdc(P-1,Q-1) = 2$ și $\frac{P-1}{2}$ și $\frac{Q-1}{2}$ nu au factori primi mici. Prodosul a două grupuri ciclice ale căror ordine sunt coprime dau un grup ciclic, grupuri din $\mathbb{Z}_{P}^{*}$ și $\mathbb{Z}_{Q}^{*}$ sunt ciclice, la fel și grupul $Q_N$ este ciclic. Acest lucru ne garantează faptul că există un subgrup ciclic în $\mathbb{Z}_{N}^{*}$ de ordin $M=P^{'}Q^{'}$. Putem estima numărul de iterații ales acestui algoritm folosind faza $1$ din protocolul Boneh-Franklin. Întâi trebuie să cunoaștem faptul că:

$$\lim_{n-> \infty} Pr_{P^{'},Q^{'}  \in [1,n] } [cmmdc(P^{'},Q^{'}]= 1 =  \frac{6}{\Pi^{2}} > 1/2 $$ 
Adică, ne asumăm faptul că numerele prime din intervalul $ \left[  2^{\frac{n-1}{2}}, 2^{\frac{n}{2}}         \right] $ sunt uniform distribuite. Singurul factor lent la generarea cheii este verificarea dacă $cmmdc(P^{'},P-1)=2$ unde $P^{'} = 4P$. Putem nota că:
$$Pr_{P^{'}}[ cmmdc(2P^{'},P^{'}) =2 ]$$
$$ = Pr_{P^{'}} [2 \nmid P^{'} \wedge 3 \nmid P^{'} ...   \wedge B \nmid P^{'} ] =(1- \frac{1}{2})(1 - \frac{1}{3})...(1- \frac{1}{B}) = \prod_{p_i \leqslant B}^{} (1- \frac{1}{P^i}) \approx \frac{1}{e^{\lambda} \ln(B)}  $$
Conform teoremei a doua a lui Merts, unde $\lambda$ este onstanta lui Euler. Așadar, va trebui să rulăm algoritmul de $ 4 \times (e^{\lambda} \ln(B)$ ori în medie pentru a putea genera un astfel de modul RSA. 
\subsubsection{Metoda distribuită de generare de chei în protocolul lui Shoup}
De ăndată ce $N$ este generat, fie $e$ primul număr mai mare decât $4 \delta^{2}$  în așa fel încât serverul îl poate calcula. Apoi, protocolul Catalano \cite{catalano} este rulat pentru a genera cheia partajată într-o manieră distribuită. La finalul protocolului, fiecare server calculează cheia ei de verificare în felul următor:
$$ v_{u,i} = v_{u}^{\delta d_i}$$
Pentru $v_u$ aleator calculat ca și $y_{u}^{2} \ mod \ N$ unde $y_u$ e concatenarea lui $H(N|i)$ pentru suficient de mulți $i$ pentru a colecta corect parametri de securitate.

\subsection{Schema lui Shoup împotriva adversarilor activi}
\subsubsection{Generarea cheilor}
La sfârșitul protocolului de genarare de chei, va trebui să se verifice, dacă informația îl poate ajuta pe adversar să afle cheia secretă. Fie $d_{i_1},...,d_{i_t}$, $t$ subsecrete ale cheii secrete, obținută de adversar la $t$ servere corupte. \\
Informația dezvăluită prin partajarea lui $d_{i_j}$. Pentru fiecare $d_{i_j}$ putem spune că: 
$$d_{i_j} = f(i_j) = a_0 + a_1i_j + ... + a_t i_{j}^{t} \ mod \ M       $$
Dacă adăugăm o a $t+1$ ecuație, $a_0=d$, vom obține următorul sistem liniar:



\[
\left\{ 
\begin{array}{c}
a_0 + a_1 i_1 + ... a_t i_{1}^{t}  = d_{i_1} \ mod \ M \\ 
a_0 + a_1 i_2 + ... a_t i_{2}^{t}  = d_{i_2} \ mod \ M \\ 
... \\
a_0 + a_1 i_t + ... a_t i_{t}^{t}  = d_{i_t} \ mod \ M \\
\end{array}
\right. 
\]

Sau o matrice $A = D \ mod \ M$

\[
\left (
\begin{array}{cc}
1 \ i_1 \ i_{1}^{2} ... i_{1}^{t} \\
1 \ i_2 \ i_{2}^{2} ... i_{2}^{t} \\
... \\
1 \ i_t \ i_{t}^{2} ... i_{t}^{t} \\
1 \ \ 0 \ \ 0 ... 0 


\end{array}
\right) 
\times
\left (
\begin{array}{c}
a_0 \\
a_1 \\
... \\
a_t  
\end{array}
\right)
=
\left(
\begin{array}{c}
d_{i_1} \\
d_{i_2} \\
... \\
d_{i_t}
\end{array}
\right)
\]

Această matrice este o matrice Vandermonde. Determinantul unei astfel de matrici este:
$$ \det(A) = \prod_{1 \leqslant j < k <t+1}^{} (i_k - i_j) \ mod \ M$$
Unde $i_{t+1} = 0$. Cum toți $i_j$ sunt distincți în $\mathbb{Z}_{M}$, $i_k - i_j \neq 0 \ mod \ M$ deoarece $l < B$. Prin urmare, toate valorile lui $d$ sunt posibile. Prin urmare, un grup de $t$ jucători nu pot obține informații despre $d$ din partajări ale lui $d$

\subsubsection{Informația dezvăluită prin verificare cheilor}
Ăentru toți $u \in [1,k]$, cheile de verificare $v_{u,i}$ ale serverelor non corupte nu dezvăluie vreo informație pentru că ele pot fi foarte ușor simulate din părți ale serverlor corupte. Simulatorul alege random $y_u \in \mathbb{Z}_{N}^{*}$, calculează 
$$v_u = y_{u}^{2 \delta e} \ mod \ N$$ 
Prin urmare $y_{u}^{d} = y_{u}^{2 \delta}$. Putem face notația: 
$$\delta d_i = \sum_{k=1}^{t+1} \lambda_{i,k}^{S} d_j \ mod \ \phi(N)$$
Notăm cu $S$ un grupt de $t+1$ valori dacă definim coeficienții Lagrange ca fiind:
$$\lambda_{i,j}^{S} = \delta \times \prod_{j^{'} \in S \smallsetminus j}^{} \frac{i - j^{'}}{j - j^{'}} \in \mathbb{Z}  $$
Simulatorul poate calcula pentru fiecare $u \ in [1,k]$:
$$v_{u}^{\delta d_i} = y_{u}^{2 \delta \lambda_{i,0}^{S}}  \times \prod_{j=1}^{t} = v_{u}^{\lambda_{i.j}^{S} d_{i_j}    } \ mod \ N     $$
unde $S = \lbrace 0,i_1,...,i_t \rbrace$. Prin urmare, un grup de t jucători nu pot lua informația de la cheile de validare ale serverelor non corupte.
\subsubsection{Protocol pentru semnătură}
Pentru a genera o semnătură a unui mesaj $m$, fiecare server $i$ calculează $x=H(m)$,$S_i = x^{2 \delta d_i}  \ mod \ N$ și trimite $S_i$ către combinatori fără vreo dovadă deoarece sunt în modelul onest dar curios. Combinatorul selectează un grup $S$ de $t+1$ valori și calculează $ w = \prod_{j=1}^{t+1} S_{i_j}^{2 \lambda_{0,i_{j}}^{S} } \ mod \ N$. \\
De aici rezultă că $w^{e} = x^{4 \delta^2}$ pentru că $s_{i_j}^{2} = x^{4 \delta d_j}$. De aici putem extrage $e$ rădăcina $x$ din $w$. Pentru că suntem în modelul onest dar curios, semnătura va fi tot timpul corectă.

\subsection{Îmbunătățirea schemei lui Shoup împotriva adversarillor activi}
\subsubsection{Dovada corectitudinii}
Fie $N$ modulul astfel încât $N=PQ$ și $P = 2p^{'} +1 $ și $Q= 2q^{'} +1 $ unde $p^{'}$ și $q^{'}$ nu au factori primi mai mici și $cmmdc(P-1,Q-1)=2$. Prin urmare, logaritmul discret al oricărui element $S_i^{2}$ în baza $g$ există, unde $S_i = x^{2 \delta d_i}$ și $\delta = l!$. Putem nota cu $v_1,...,v_k$ un $k$-tuplu de elemente aleatoare în $(Q_N)^k$ astfel încât acest tuplu poate genera cu o probabilitate mare tot grupul $Q_N$ de ordin $M=p'q'$ astfel încât pentru fiecare $x \in Q_N, \exists (a_1,...,a_k) \ in [0,M] $ astfel încât $x = \prod_{i=1}^{k} v_i^{a_i} \ mod \ N$
Fiecare server $i$ are un $k$-tuplu de chei de verificare $v_{1,i} = v_1^{d_i} \ mod \ N,...,v_{k,i} = v_k^{d_i} \ mod \ N$. El calculează o semnătură, $S_i = x^{2 \delta d_i} \ mod \ N$, unde $d_i$ este semnătura $i$ a lui $d$, și dovedim că:
$$ \log_{v_1} (v_1,i) = ... = \log_{v_k} (v_k,i) = \log_{x^{4 \delta}} (s-{i}^{2}) = d_i \ mod \ M $$
Acum, descriem "dovada corectitudinii" și lăsăm $d_i \in [0,M]$ să fie secretul partajat al serverelor și $A$ și $B^{'}$ două numere întregi astfel încât $\log(A) \geqslant \log(B^{'} Mh) +k_2$ unde $B^{'}$ și $k_2$ sunt parametri de securitate și $h$ este numărul de runde. În final, $k_1$ este un parametru, astfel încăt probabilitatea de falsificare este:
$$1/B^{\prime ^{h}} \leqslant \frac{1}{2^{k_1}}$$
Cel care face verificarea, generează aleator un $r \in [0,A]$. Apoi el calculează:
$$t= (v_{1}^{'},...,v{k}^{'},x^{'})=(v_{1}^{r},...,v_{k}^{r},x^{4 \delta r})$$
Fie $e$, reprezentând primii $b^{'} =\log(B^{'})-1$ biți din valuarea hashului.
$$ e= [H(v_1,...,v_k,x^{4 \delta},v_{1,i},..v_{k,i},S_{i}^{2},v_{1}^{'},...,v_{k}^{'},x^{'})]_{b^{'}} $$
Și verificăm dacă $0 \leqslant z \leqslant A $


\subsection{Concluzia}
Am arătat cum trebuie să evităm numerele prime sigure în schema lui Shoup în așa fel încât dovada să rămână corectă. Am considerat că mediile în care am lucrat sunt cu grad de securitate ridicat(ex scheme de vot electronic).
\\ Pe scurt, folosim diferit tehnici pentru a dovedi că:
\begin{enumerate}
\item Grupul pătratelor este ciclic.

\item Generăm $P$ și $Q$ astfel încât $P^{'}$ și $Q^{'}$ să nu conțină factori primi mici

\item Generăm un set de generatori $Q_N$ generând aleator diferiți generatori $Q_N$
\end{enumerate} 
În final, arătăm cum trebuie adaptată schema lui Shoup pentru a lucra cu diferite elemente care generează $Q_N$, în loc de unul singur.


\section{Bazele matematice} 
    \subsection{Comportamentul asimptotic}
     \subsubsection{Analiza unui algoritm}
      Cel mai bun parametru de securitate o reprezintă lungimea unei chei. O cheie mai mare ne va
      asigura un nivel de securitate ridicat, dar operațille vor necesita un timp mai mare și vor consuma
      mai multă memorie. În momentul actual, lungimea unei chei RSA este de $1024$ de biți. Această lungime de 
      cheie se crede a fi securizată ținând cont de puterea computațională actuală.
     \subsubsection{Viteza unui algoritm}
      Pentru algoritmii noștri, noi trebuie să alegem operația cea mai critică pentru a estima viteza 
      (pentru un algoritm de sortate, acest lucru îl poate reprezenta operatorul de comparație). În cazul
      nostru, operatorul critic este înmulțirea. 
     \subsubsection{Notatia $O$}
      De obicei, se va folosi această notație pentru a evalua viteza unui algoritm. Notația matematică arată 
      în felul următor \\
      $$ f = O(g) \Leftrightarrow \frac{f(x)}{g(x)} \longrightarrow 0 , x\longrightarrow +\infty $$
      
     \subsection{Aritmetica numerelor întregi}
      \subsubsection{Operațiile de bază}
       Avem o serie de operații de bază la îndemâna noastră, cum ar fi operațiile logice, evaluarea condițiilor sau saltul în program. Aceste lucruri ne ajută pentru a calcula operații mai complexe cum ar fi înmulțirea a doua numere pe $n$ biți. Înmulțirea sau împărțirea acestor numere se numesc operații cu multiplă precizie. 
      \subsubsection{Reprezentarea Radix}
      Numerele întregi pozitive pot fi reprezentate în multiple moduri. Cea mai de bază reprezentare a acestora este baza $10$, un astfel de număr este reprezentat prin serii de $0$ și $9$. Spre exemplu $ a = 123 $ înseamnă $ a = 1 * 10^2 + 2*10^1 + 3*10^0$. Prin extensie, este posibil să reprezentăm un întreg utilizând o baza b: $ a = a_k * b^k + a_k-1*b^k-1 + ... + a_0*b^0 $. Pentru în număr $a$ și o bază $b$ există mereu această reprezentare și este unică. Deoarece calculaoarele lucrează cu $0$ și $1$, baza $2$ este mereu folosită. Așadar, vom folosi următoarea notație \\
      $$ a=(111011)_2 = 2^5 + 2^4 + 2^3 + 0*2^2 + 2^1 + 2^0 $$
      \subsection{Aritmetica modulară}
       \subsubsection{Reducerea modulară}
        Majoritatea criptosistemelor sunt bazate pe grupuri finite; spre excemplu $ Z_N $. Fiecare element $x$ din acest grup poate fi notat ca și: \\
        $$ x = r  \ mod \ N \ \Leftrightarrow \exists q \in Z , x = r+q*N$$
       \subsubsection{Inversiunea}
         Inversiunea poate fi calculată datorită algoritmului Euclid Extins, care nu calculează doar cel mai mare divizor comun a două numere întregi $x$ și $y$, dar găsește și două numere întregi $ \alpha $ și $  \beta $ astfel încât $ cmmdc(x,y) = \alpha * x + \beta * y$ \\
        Dacă dorim să aflăm inversul lui  $x \ mod \ N$ (asumând faptul că numere sunt coprime, adică $cmmdc(x,N)=1)$ apoi calculăm $Xcmmdc(x,N)$ și obținem $ \alpha * x + \beta * N = 1$. Modulo $N$, această expresie devine $\alpha * x  = 1 \ mod \ N$; în alte cuinte $\alpha= x^{-1} \ mod \ N$
        
       
    \section{RSA Clasic}
     \subsection{Exponențiere Rapidă}
      \subsubsection{Descrierea algoritmului left-to-right}
       Această metodă de exponențiere este bazată pe reprezentarea binară a exponentului și ne permite să calculăm un exponent cu un număr mic de înmulțimiri și pătrate. Luăm baza $M$, exponentul e și modulul $N$ ca și input, și rezultatetul exponențierrii $C = M^e \ mod \ N$ ca și output. Pe lângă faptul că avem o reprezentare arbitrară a lui $ e = \sum_{i=0} ^ {k-1} e_i * 2^i $, unde $ e_i $ este $0$ sau $1$. Putem transforma exponentul în următoarea expresie: \\
       $$ M^e = M^{\sum_{i=0} ^ {k-1} e_i * 2^i} $$ 
       $$ =  \prod_{i=0}^{k-1} M^{e_i*2^i} $$ 
       Folosind acea relație, vom putea calcula recursiv rezultatul: prima dată îl vom înițializa cu $1$, apoi vom merge prin reprezentarea binară a exponentului. Dacă cifra de la poziția $i$ este $1$, atunci o vom multiplica cu rezultatul $ M^{2^i}$. Dar acest lucru se poate face mai rapid: dacă inițializăm rezultatul cu 1 și mergem prin reprezentarea binară a exponentului de la stânga către d_Reapta. La fiecare pas, ridicăm la pătrat rezultatul și în înmulțim cu M dacă unitatea de pe acea poziție este $1$. La final, rezultatul va fi multiplicarea acestuia cu $ M^{2^i}$.
      \subsubsection{Corectitudinea algoritmului left-to-right}
      Vom dovedi prin inducție că acest aloritm funcționează. Să spunem că la un anumit pas $i$ avem $ C_i = \prod_{j=i}^{k-1} {M^{e_j*2^{j-i}}} mod N$. La următorul pas, vom calcula pătratul și o înmulțire dacă $ e_{i-1} = 1 $. Prin urmare: \\
      $$ C_{i-1} = M^{e_{i-1}}*C_{i}^2 \ mod \ N$$
      $$ = M^{e_{i-1}} * \left( \prod_{j=i}^{k-1} M^{e_j*2^{j-i}} \right)^2 \ mod \ N $$
      $$ = M^{e_{i-1}} * \prod_{j=i}^{k-1} M^{e_j*2^{j-i+1}} \ mod \ N$$
      $$ = \prod_{j=i-1}^{k-1} M^{e_j*2^{j+)i-1)}} \ mod \ N $$
      
      La începutul buclei, la pasul $ k-1 $ afirmația este adevărată deoarece $ C = M^{e_{k-1}} mod N$. Prin inducție, afirmația este adevărată cât timp $ i=0$. Iar pentru $i=0$ avem: \\
      $$ C= \prod_{j=0}^{k-1} M^{e_j * 2^j}  \ mod \ N $$
      
     \subsection{Teorema chineză a resturilor}
      \subsubsection{Descrierea}
      Teorema chineză a resturilor ne permite să reducem timpul computațional pentru o decryptare clasică RSA. Mai general, teorema formează o bijecție între $ \mathbb{Z}/m\mathbb{Z} $ și produsul cartezian \\
      $$ \prod_{i=0}^{k} \mathbb{Z}/m_i\mathbb{Z} $$
      Asumând faptul că $ m = \prod_{i=0}^{k} m_i $ și că $ m_i $ nu au divizori comuni. Spre exemplu, există un izomorfism între $ \mathbb{Z}/n\mathbb{Z}$ și $\mathbb{Z}/p\mathbb{Z} \times \mathbb{Z}/q\mathbb{Z}  $ în loc de $ \mathbb{Z}/n\mathbb{Z} $, p și q reprezentând două numere prime astfel încât $ n=pq$. Spunem că lungimea în biți a lui $p$ și $q$ este jumătate din lungimea în biți ai lui $n$, costul înmulțirii este teoretic divizat prin 2. Este ușor a calcula imaginea unui anumit a, dar dacă $ a= a_i mod m_i$ este dat, atunci reciproca nu este trivială. Obiectul teoremei este să dea soluția unică a unui sistem de forma: \\
    \[
\left\{ 
\begin{array}{c}
a=a_1 \ mod \ m_1 \\ 
... \\ 
a=a_k \ mod \ m_k
\end{array}
\right. 
\]
Prin \textbf{Izomorfism} se înțelege o funcție între două mulțimi peste care s-au definit câte o structură algebrică, funcție care satisface două condiții: \\
\begin{enumerate}
\item Este morfism (adică păstrează structura algebrică, în sensul că orice relație ar exista între niște elemente din prima mulțime, relația respectivă se regăsește între elementele corespunzătoare - imagini prin funcția studiată - din a doua mulțime)

\item admite un alt morfism care "inverseaă" (formal pentru $f:A \longrightarrow B, \exists g:B\longrightarrow A$ morfism astfel încât $g \circ f = 1_A$ și $f \circ g =1_B$. Această condiție necesită ca $f$ să fie bijectivă, dar cere în plus ca inversia ei să fie tot morfism.
\end{enumerate} 
	 \subsubsection{Corectitudinea teoremei}
	 Căutăm să găsim acel $a$, astfel încât $ a = a_i \ mod \ m_i $ pentru $i$ de la $1$ până la $k$. Să dovedim că $ a = \sum_{i=0}^{k} a_i * M_i * y_i $ este o soluție a sistemului. \\
	 $M_i= \prod_{j=0,j \neq i}^{k} m_j $ și $M_j=0 \ mod \ m_i $ dacă $j \neq i$, de aceea: 
	 $$ a = a_i * M_i * y_i \ mod \ m_i $$
	 Dar am ales $y_i$ astfel încât $y_i = M_{i}^{-1} \ mod \ m_i$ ; în alte cuvinte $y_i * M_i = 1 \ mod \ m_i$. În final, obținem pentru i de la 1 până la k :
	 $$ a = a_i \  mod \ m_i$$
	 
	 \subsection{Algoritmul lui Garner}
	  \subsubsection{Descrierea algoritmului}
	  Utilizarea clasică a teoremei chineze a resturilor necesită un modul $N$ produs a doupă numere prime $P$ și $Q$. Este posibil să estimăm calculul a celor doupă inverse datorită algoritmului Garner. Totuși, costul din punct de vedere al memoriei este mai mare. Ca și în algoritmul precedent, trebuie să găsim $M$ astfel încât $ M = M_P \ mod \ P$ și $M = M_Q \ mod \ Q$. Mai avem un parametru $ P_{inv_Q} = P^{-1} \ mod \ Q$.
	  \subsubsection{Corectitudinea algoritmului}
	  Vrem să calculăm M astfel încât $M =M_P \ mod \ P$ și $M=M_Q \ mod \ Q$ și $P_{inv_Q}=P^{-1} \ mod \ Q$. Să arătăm că: \\
	  $$ M=M_P + V*P \ mod \ N$$
	  unde $ V=P_{inv_Q} * (M_Q-M_P) \ mod \ Q$ \\
	  $M = M_P \ mod \ P$ și : \\
	  $$P*V= P* P_{inv_Q} * (M_Q - M_P) \ mod \ Q$$
	  $$ = M_Q - M_P \ mod \ Q$$
	  În final: \\
	  $$ M= M_P + M_Q \ mod \ Q$$
	  $$ = M_Q \ mod \ Q $$
	  
	  \subsection{Implementări rapide RSA}
	  Am prezentat o optimizare a algoritmului RSA folosind teorema chineză a resturilor și o exponențiere mai rapidă. Cele doupă inverse sunt de obicei necesare pentru teorechema cineze sunt reduse la un singur invers. Prin acest mod, viteza de decriptare crește de aproximativ $4$ ori.
	  \subsubsection{Generarea cheilor, criptare și decriptare}
	  \begin{enumerate}
	    \item \textbf{Generarea cheilor}: \\
	    Generarea cheilor este aceeași ca și în RSA standard: avem ca input parametrul de securitate $n$, alegem două numere prime cu lungimea în biți fiind jumătatea lui $n$ după care le înmulțim. Apoi alegem în număr întreg $e$ astfel încât $ \phi(N) $ și $e$ sunt relativ prime. În final calculăm d asfel încât $ ed=1 \ mod \ \phi(N)$ și după să-l reducem modulo $(P-1)$ și $(Q-1)$. Apoi calculăm $P_{inv_Q} = P^{-1} \ mod \ Q$: toate aceste valori sunt fixate și sunt necesare pentru decriptare. Cele două numere $<N,e>$ reprezintă cheile publice și $<P,Q,cmmdc,d_Q,P_inv_Q>$ sunt cheile secrete.
	    
	    \item \textbf{ Criptarea}: \\
	    Mesajul criptat, va trebui întâi convertit la un număr întreg. Sunt anumite tipuri de algoritm care fac această conversie (o modalitate ar fi să folosim caracterele ascii). Având plaintextul M, este ușor să calculăm $C = M^e \ mod \ N$
	    
	    \item \textbf{Decriptarea}: \\
	    Pentru decriptare nu vom face direct calculul $M=C^d \ mod \ N$, ci vom folosi una din schemele eficiente prezentate mai sus. $M_P= C_{P}^{d_P} \ mod \ P$ și $M_Q = C_{Q}^{d_Q} \ mod \ Q $ unde $C_P = C \ mod \ P$, $cmmdc= d \ mod \ P-1 $ și $C_Q = C \ mod \ Q. d_Q = d \ mod \ Q-1 $. Apoi este posibil să reveni la plaintextul M datorită teoremei chineze a resturilor. Această metodă este mai rapidă pentru că vom avea 2 exponențiere de lungine $n/2$ biți în loc de un de lungime $n$.
	  \end{enumerate}
	  
	  \section{RSA Rebalansat}
	   \subsection{Generarea cheilor, criptare și decriptare}
	    \subsubsection{Generarea cheilor}
	    Algoritmul primește $2$ parametri de securitate ca și input: $n$ (de obicei $1024$ biți) și $k$(de obicei $160$ biți) unde $k<n/2$. Apoi se aleg două numere prime $P$ și $Q$ verificând că $cmmdc(P-1,Q-1)=2$ și care au lungimea $n/2$. Modulul N este $N=PQ$. Apoi alegem random două valori pe $k$ biți $d_P$ și $d_Q$ astfel încât $cmmdc(d_P,P-1)=1, cmmdc(d_Q,Q-1)=1$ și $(d_P=d_Q \ mod \ 2$. Exponentul secret $d$ trebuie să verifice: $d=d_P \ mod \ P-1$ și $d=d_Q \ mod \ Q-i$. Nu putem calcula direct $d$ folosind teorema chineză a resturilor pentru că $P-1$ și $Q-1$ nu sunt relativ prime, dar noi le alegem astfel încât $cmmdc(P-1,Q-1)=2$ prin urmare:
	    $$cmmdc(\frac{P-1}{Q-1},\frac{Q-1}{2} )=1  $$
	     De asemenea știm că $ d_P=d_Q \ mod \ 2$. Fie $ a=d_P \ mod \ 2 $. Datorită teoremei chineze a resturilor, putem calcula un $d\textprime$ care verifică:
	    $$d\textprime = \frac{d_P-a}{2} \ mod \ \frac{P-1}{2} $$
	    $$d\textprime = \frac{d_Q-a}{2} \ mod \ \frac{Q-1}{2} $$
	    În alte cuvinte, există două numere întregi $k_1 și k_2$ astfel încât: 
	    $$d\textprime = \frac{d_P-a}{2} + k_1 * \frac{P-1}{2} $$
	    $$d\textprime = \frac{d_Q-a}{2} + k_2 * \frac{Q-1}{2} $$
	    Fie $ d=2d\textprime +a$ care verifică:
	    $$ d=(d_P-a) + k_1 * (P-1) +a$$
	    $$ d=(d_Q-a) + k_2 * (Q-1) +a$$
	    Modulo $P-1$ și $Q-1$ obținem:
	    $$d=d_P \ mod \ P-1$$
	    $$d=d_Q \ mod \ Q-1$$
	    Pentru a calcula exponentul public e, trebuie doar să calculăm inversul lui $d$ modulo $\phi(N)=(P-1)(Q-1)$. Acest lucru este permis deoarece $cmmdc(d_P,P-1)=cmmdc(d_Q,Q-1)=1$. Prin urmare, $cmmdc(d,P-1)=cmmdc(d,Q-1)=1$. În final $cmmdc(d,\phi(N))=1$. Nu avem control asupra lui e care este de ordinul lui $N$. Criptarea nu va fi la fel de rapida ca și criptarea clasică RSA dar vom putea mări viteza decriptării.
	   \subsubsection{Criptarea}
	    Aceasta este exact ca și în RSA standard, doar că $e$ este mult mai mare. Cheia publică este $<N,e>$.
	    \subsubsection{Decriptarea}
	    Putem decripta criptotextul C prin calculul $M_P = C^{d_P} \ mod \ P$ și $M_Q=C^d_Q mod Q$. Folosind teorema chineză a resturilor putem recupera plaintextul inițial $M$ dacă facem verificarea $M=M_P \ mod \ P$ și $M=M_Q \ mod \ Q$.
	    
	    \section{Multi-Prime RSA}
	     \subsection{Algoritmul Garner cand $N=PQR$}
	     \subsubsection{Descrierea algoritmului}
	     Algoritmul Garner este o optimizare a teoremei chineze a resturilor, ce ne permite să îmbunătățim viteza de decriptare, dar cu un consum mai mare al memoriei. Mai sus am prezentat varianta pentru două numere prime, dar în acest caz vom avea $3$ numere prime. Algoritmul are ca input $M_P,M_Q,M_R,P,Q,R$ și $N$, unde $N=PQR$. De asemenea, trebuie să calcuulăm și $PQ_{inv_R}$ și $P_{inv_Q}$, verificând că $PQ_{inv_R}=(PQ)^{-1} \ mod \ R$ și $P_{inv_Q}=P^{-1} \ mod \ Q$. Calculăm $M$ astfel încât: \\
	         \[
\left\{ 
\begin{array}{c}
M=M_P \ mod \ P \\ 
M=M_Q \ mod \ Q \\ 
M=M_R \ mod \ R
\end{array}
\right. 
\]

		\subsubsection{Corectitudinea algoritmului}
		Dorim să calculăm $M=M_P \ mod \ P$, $M=M_Q \ mod \ Q $ și $M=M_R \ mod \ R $. Lafel dorim să avem calculat și $P_inv_Q=P^{-1} \ mod  \ Q$ și $PQ_{inv_R}=(PQ)^{-1} \ mod \ R$. M verifică: 
		$$M=M_{PQ} + P*Q(M_R-M_{PQ})*(PQ_{inv_R}) \ mod \ N$$
		Știind faptul că  $P*Q*(PQ_{inv_R})=1 \ mod \ R$ obținem:
		$$M=M_{PQ}+(P*Q*(PQ_{inv_R}))*(M_R-M_{PQ}) \ mod \ R$$
		$$M=M_{PQ} + M_R - M_{PQ} \ mod \ R$$
		în final obținem $ M=M_R \ mod \ R $
		La fel vom proceda pentru această ecuație $mod \ Q$ și $mod \ P$ și vom obține:
		$$M=M_Q \ mod \ Q$$
		$$M=M_P \ mod \ P$$
		
		\subsection{Multi-Prime RSA modulo $N=PQR$}
		 \subsubsection{Descrierea cryptosistemului}
		 \begin{enumerate}
		  \item \textbf{Generarea cheilor}: \\
		  Generarea cheilor este aceeași ca și la RSA clasic, diferă doar faptul că sunt $3$ numere prime în loc de $2$. Avem ca input, parametrul de securitate $n$, alegem 3 numere prime $P$, $Q$ și $R$ care au lungimea în biți $n/3$ și le înmulțim pentru a obține modulul $N=PQR$. Apoi alegem un număr întreg $e$ astfel încât $\phi(N)=(P-1)(Q-1)(R-1)$ și e să fie relativ prime. În final, calculăm d astfel încât $ed=1 mod \phi(N)$ și $d_P=d \ mod \ P-1, d_Q= \ mod \ Q-1$ și $d_R=d \ mod \ R-1$. De asemenea calculăm și $PQ_{inv_R}=(PQ)^{-1} \ mod \ R$ și $P_{inv_Q}=P^{-1} \ mod \ Q$. Cele două numere întregi $<N,e>$ sunt cheile publice și $<P,Q,R,d_P,d_Q,d_R,PQ_{inv_R},P_{inv_Q}>$ sunt cheile private.
		  
		  \item \textbf{Criptarea}: \\
		  Partea de criptare este lafel ca și la RSA clasic.
		  
		  \item \textbf{Decriptarea}: \\
		  Principiul este cam același: Se folosește teorema chineză a resturilor doar că în loc de $2$ numere prime vom avea $3$. Această decriptare este mai rapidă, deoarece lungimea în biți ale numerelor întregi este mai scurtă. În loc de o singură exponențiere vom avea 3 exponențieri de lungime de 3 ori mai mică. În general viteza acestui algoritm este de 9 ori mai rapidă decât RSA multi-prime care nu folosește teorema chineză a resturilor.
		  
		 \end{enumerate}
		 
		 \subsection{Generalizarea algoritmului Garner}
		 Deși, utilizarea a mai mult de $3$ numere prime reprezintă un incident de securitate, lungimea unei chei RSA ar putea deveni mai mare în viitor, și ne va permite să folosim și o formă mai generală având $b$ numere prime, în acest caz $N$ va fi : $N=\prod_{i=1}^{b} P_i$.
		 \subsubsection{Descrierea algoritmului în forma generală}
		 \begin{enumerate}
		 \item \textbf{Generarea cheilor}: \\
		 Generarea cheilor este aceeași ca și până acum doar că vom avea un număr b de numere prime în loc de $2$ sau $3$: avem ca input un parametru de securitate $n$, alegem $b$ numere prime care au lungimea $n/b$ biți și le înmulțim pentru a obține N. Alegem e astfel încât $\phi(N)=\prod_{i=1}^{b}(P_i -1)$ și e sunt relativ prime. În final calculăm d astfel încât $ed=1 \ mod \phi(N)$ și $d_i = d \ mod \ P_i -1$. La fel vom calcula și acei inverși ( de data aceasta îi vom nota cu $A_2,...,A_b$. Vom avea parametri publici $<N,e>$ și cei secreți $<P_1,...,P_b,d_1,...d_b,A_2,...,A_b>$.
		 
		 \item \textbf{Criptarea}: \\
		 Criptarea este lafel ca și cea clasică
		 \item \textbf{Decriptarea}: \\
		 Principiul este același, s va folosi teorema chineză a resturilor, unde $N=\prod_{i=1}^{b} P_i$.Va trebui să facem b exponențieri de lungine $n/b$. Este posibil să avem o viteză de $b^2$ ori mai rapidă decât RSA fără teorema chineză a resturilor.
		 \end{enumerate}
		
		\section{Multi-Power RSA}
		 \subsection{Hensel lifting}
		  \subsubsection{Ideea de baza la Hensel lifting}
		  Folosind un modul $N=P^2Q$ folosind în mod clasic teorema chineză a resturilor, făcând o decriptare RSA ar fi mai înceată decât dacă am folosi un modul $ N=PQ$. Când calculăm $ \mathbb{Z}/P^2\mathbb{Z}$, ajungem să avem lungimi de $2n/3$ biți, pe când în $\mathbb{Z}/Q\mathbb{Z}$ avem lungimi de $n/3$. Așadar, va trebui să-l scriem pe $P^2$ sub o altă formă.
		  \subsubsection{Justificarea matematică}
		  Vom încerca să scriem reprezentarea plaintext $M_P \ modulo \ P^2$
		  $$ M_P=K_0 + P*K_1 \ mod \ P^2$$
		  Dacă vom calcula $C_P=M_{P}^{e}$ obținem:
		  $$ C_P = (K_0 + P*K_1)^e \ mod \ P^2$$
		  $$ = \sum_{i=0}^{e} \binom ie * K_{0}^{i} * P^{e-i} * K_{i}^{e-i} mod P^2 $$
		  Acest binom se va reduce la :
		  $$ C_P = K_{0}^{e}  + e*P*K_{0}^{e-1} * K_1 \ mod \ P^2 $$
		  Putem calcula foarte ușor pe $K_0$:
		  $$K_0=C_{P}^{d_P} \ mod \ P$$
		  Fie $E = C_P - K_{0}^{e} \ mod \ P^2$ de unde rezultă:
		  $$ K_1=\frac{E}{P} (e*K_{0}^{e-1} \ mod \ P)^{-1} \ mod \ P $$
		  Acum putem recupera mesajul $M_P = K_0 + P * K_1 \ mod \ P^2$
		  
		  \subsection{Multi-Power RSA modulo $N=P^2Q$}
		  \subsubsection{Algoritmul}
		  \begin{enumerate}
		   \item \textbf{Generarea cheilor}: \\
		   Avem ca input parametru de securitate n, alegem două numere prime $P$ și $Q$, care au lungimea $n/3$ și calculăm modulul $N=P^2Q$. Apoi elegem e ca și în partea standard RSA și calculăm d astfel încât $ed=1 \ mod \ (P-1)(Q-1)$. În final, calculăm $d_P= d \ mod \ P-1$ și $ d_Q=d \ mod \ Q-1$. De asemenea calculăm și $P_{inv_Q}^{2}$ și $e_{inv_P}$. Cele două numere întregi $<N,e>$ vor reprezenta cheia publică, iar $<d_P,d_Q,P,Q,P_{inv_Q}^{2},e_{inv_P}>$ reprezintă cheia secretă. 
		   
		   \item \textbf{Criptarea}: \\
		   Criptare clasică RSA
		   
		   \item \textbf{Decriptarea}: \\
		   La decriptare vom calcula $M_P = C_{P}^{d} \ mod \ P^2$, unde $C_P = C '\ mod \ P^2$ și $M_P = M \ mod P^2$ folosind algoritmul Hensel. Ne permite să alculăm exponentul unui număr de lungime $2n/3$ biți la costul unui număr de lungime $n/3$ biți. În final putem recupera plaintextul inițial folosind teorema chineză a resturilor. Această metodă are o viteză de circa 13.5 ori mare.
		  \end{enumerate}
		  
		  \subsection{Generalizarea ideii}
		  În acest moment suntem limitați să avem $b=2$ unde $N=P^bQ$, deoarece lungimea maximă în acest moment este de 1024 de biți.
		  \subsubsection{Ideea de bază}
		  Având $M \ mod \ P$, putem recupera plaintextul inițial $ M \ mod \ P^2$ datorită algoritmului Hensel. Totuși, dacă executăm acest algoritm într-o buclă vom putea recupera mesajul chiar și cu o putere mai mare decât 2. După fiecare buclă, vom obține $ M  \ mod \ P^i$, început cu i de la 1 până la $b$. La final, obținem $M \ mod \ P^b$. Vom avea $M_{P,i}$, plaintextul modulo $P^i$. Vom arăta ca se poate recupera plaintextul folosind modulo $P^{i+1}.$
		  $$M_{P,i+1} = K_0 +K_1 * P^i \ mod \ P^{i+1}$$
		  Putem scrie criptotextul $C_{P,i+1}$ modulo $P^{i+1}$ în următorul fel:
		  $$C_{P,i+1} = M_{P,i+1}^{e} \ mod \ P^{i+1}$$
		  $$ = (K_0+K_1*P^i)^e \ mod \ P^{i+1} $$
		  După ce vom desface acea paranteză aplicând Binomul lui Newton, ecuația se va reduce la:
		  $$ C_{P,i+1} = K_{0}^{e} + e*K_{0}^{e-1} *P^i*K_1 \ mod \ P^{i+1}$$
		  Mai departe, vom înlocui pe $K_0$ cu $M_{P,i}$, și vom aduce primul termen $M_{P,i}^{e}$ în partea stângă. Vom obține:
		  $$C_{P}^{i+1} - M_{P,i}^{e} = e*M_{P,i}^{e-1} * P^i * K_1 + k *P^{i+1}$$
		  Ca și în varianta precedentă unde aveam $b=2$, vom înlocui pe $C_{P}^{i+1} - M_{P,i}^{e}$ cu $E$. Prin urmare, $K_1$ va fi egal cu:
		  $$K_1 = \frac{E}{P^i} * (e*M_{P,i}^{e-1})^{-1} \ mod \ P$$
		  În final se obține:
		  $$M_{P,i+1}= M_{P,i} + K_1 * P^i \ mod \ P^{i+1}$$
		  \subsection{Multi-Power RSA modulo $N=P^bQ$}
		  \subsubsection{Algoritmul}
		  \begin{enumerate}
		  \item \textbf{Generarea cheilor}:\\
		  Vom avea ca parametru de securitate $n$, vom alege cele două numere prime $P$ și $Q$, care au lungimea de $n/(b+1)$ biți și calculăm $N=P^bQ$. Apoi îl alegem pe $e$ în modul standard RSA, după care îl calculăm pe $d$ astfel încât $ed=1 \ mod \ (P-1)(Q-1)$. În final, vom calcula $d_P= d \ mod \ P-1$ și $d=q \ mod \ Q-1$. De asemenea vom calcula $P_{inv_Q}^{2}$ și $e_{inv_P}$. Cele două numere întregi $<N,e>$ sunt cheile publice, iar $d_P,d_Q,P,Q,(P_{inv_Q}^{2},e_{inv_P}>$ sunt cheile secrete.
		  \item \textbf{Criptarea}:
		  Criptarea se face în modul clasic RSA
		  
		  \item \textbf{Decriptarea}: \\
		  Vom calcula $M_P = C_{P}^{d} \ mod \ P^b $ unde $C_P = C \ mod \ P^b$ și  $M_P = M \ mod \ P^b$ folosind algoritmul Hensel. În final, vom recupera plaintextul înițial folosind teorema chineză a resturilor. De asemnea calculăm $M_Q= C_{Q}^{d} \ mod \ Q$ și obținem plaintextul folosind algoritul Garner.
		  \end{enumerate}
		  
		  \section{Batch RSA}
		  Ideea este destul de schimbată pentru această variantă. Această constă în gruparea unor cryptotexte.
		  \subsection{Ideea de bază}
		  \subsubsection{Notație}
		  De data aceasta, vom folosi echivalentul notației $M=C^d \ mod \ N$ care este $M=C^{1/e} \ mod \ N$ deoarece $e$ este invers modularul lui $d$.
		  
		  \subsubsection{Formule de bază pentru decriptare}
		  Spunem că avem $p$ numărul de plaintexte, respectiv numărul de exponenți $e_i$ care același modul N. Ne vom folosi de următoarele:
		  $$ e= \prod_{i=1}^{p}e_i$$
		  $$ A =\left( \left(\prod_{i=1}^{p} C_{i}^{e/e_i} \right) \ mod \ N \right)^{1/e} \ mod \ N$$
		  Fiecare plaintext $M_i$ va fi aflat cu ajutorul următoarei formule:
		  $$ M_i = \frac{A^{a_i}}{C_{i}^{(a_i-1)/e_i} * \prod_{j=1,j \neq i }^{p } C_{j}^{a_i/e_j }                                 } \ mod \ N$$ 	
		  Unde $a_i$ are următoarea proprietate:
		  $$a_i = 1 \ mod \ e \ , \ a_i=0 \ mod \ e_j$$	  
		  
		  \subsubsection{Decriptarea a două texte}
		  Vom avea două mesaje $M_1$ și $M_2$, care au cheile publice $<N,3>$ și $<N,5>$. Așadar, vom avea criptotextele $C_1 = M_{1}^{3} \ mod \ N$ și $C_2 = M_{2}^{5} \ mod \ N$.Pentru aflarea plaintextelor, folosind formula prezentată anterior, vom obține:
		  $$ A=(C_{1}^{5} * C_{2}^{3})^{1/15} $$
		  $$\frac{A^{10}}{C_{1}^{3} * C_{2}^{2}} = \frac{C_{1}^{10/3} * C_{2}^{2}}{C_{1}^{3} * C_{2}^{2} }=M_1$$
		  $$\frac{A^6}{C_{1}^{2} *C_{2}}=\frac{C_{1}^{2} *C_{2}^{6/5}}{C_{1}^{2} * C_{2}}=M_2 $$
		  
		  \subsection{Optimizări}
		  \subsubsection{Teorema chineză a resturilor}
		  Ca și în alte variante de RSA, putem folosi teorema chineză a resturilor pentru a reduce timpul. Se poate implementa folosind și algoritmul lui Garner.
		  \subsubsection{Calcului unui singur invers modular}
		  Când îl calculăm pe $M_i$, de asemenea noi vom calcula și o serie de inverși. În loc să calculăm $p$ inverși independent, cea mai bună soluție ar fi să aducem acele frații la același numitor, și să calculăm un singur invers.
		  \subsection{Îmbunătățirea batch RSA: Tehnica lui Mongomery}
		
		
		
		
		
		
		  \subsubsection{Descrierea algoritmului}
		  Acest algoritm va avea ca și input numerele întregi și modulul $N$, și calculează produsul întregilor inversați:  
		  \begin{algorithm}[H]
		   \caption{Tehnica lui Mongomery}
		   \textbf{Input:} $A_1,...A_p,N$ \\
		   \textbf{Output:} $Z_1=A_{1}^{-1},...,Z_p=A_{p}^{-1} \ mod \ N$
		   \begin{algorithmic}
		   	\State $X \gets A_1$
		   	\For {$i$ from $2$ to $p$}
		   	\State $X \gets X_{i-1}*A_i \ mod \ N$
		   	\EndFor
		   	\State $Z_1 \gets X_{p}^{-1} \ mod \ N$
		   	\For{$i$ from $p$ down to $2$}
		   		\State $Z_i \gets X_{i-1} * Z_1 \ mod \ N$
		   		\State $Z_1 \gets Z_1 * A_i \ mod \ N$
		   		\State
		   	\EndFor
		   	\State \textbf{return} $(Z_1,...,Z_p)$ 
		   \end{algorithmic}
		   \end{algorithm}
		   
		   \subsubsection{Corectitudinea algoritmului}
		   Valorile $X_i$ calculate la primul for sunt produsul valorilor $A_j$ de la $1$ la $i$:
		   $$ X_i=\prod_{j=1}^{i} A_j \ mod \ N$$
		   După care $Z_1$ va reprezenta produsul inverșilor, adică:
		   $$Z_1=\prod_{j=1}^{i} A_{j}^{-1} \ mod \ N$$
		   Fiecare $Z_i$ va fi înmulțit cu $X_{i-1} * Z_1$ iar $Z_1$ va fi înmulțit cu $A_i$ la fiecare pas $i$. În final vom obține:
		   $$Z_i=A_{i}^{-1}$$ 
		   \subsection{Îmbunătățirea RSA folosind tehnica lui Shamir}
		   \subsubsection{Descrierea algoritmului}
		   În acest algoritm vom primi ca și input $M_1,M_2,...M_p$, $p$ exponenți $e_1,...,e_p$ și modulul $N$. Reprezentarea binară a fiecăruia este cunoscută: $e_i=(e_{i,k-1},...e_{i,0})_2$. Calculăm $C=M_{1}^{e_1}*...*M_{p}^{e_p}$. Acest calcul este mult mai rapid decât daca am face exponențieri consecutive.
		   \subsubsection{Explicație}
		   La primul pas, vom calcula toate produsele posibile pentru $M_i$. Vom forma o bijecție $b$, definită prin: \\
		   $$b:i=(i_{p-1}...i_0)_2 -> \prod_{j=0}^{p-1} M_{j}^{i_j} \ mod \ N$$
		   unde $i_j \in \lbrace  0,1  \rbrace $
		   La pasul de evaluare, vom proceda la fel ca și în algoritmul left-to-right (metoda de exponențiere), dar în lo să înmulțim cu o singură bază $M$, va trebui să alegem o bază corectă, această putând fi diferită de $M$. Va trebui să calculăm: 
		   $$ C = \prod_{i=1}^{k} M_{i}^{e_i} \ mod \ N$$
		   Putem folosi reprezentarea binară a lui $e_i$:
		   $$ C = \prod_{i=1}^{k} M_{i}^{\sum_{j=0}^{p-1} e_{i,j} * 2^j} \ mod \ N$$
		   $$ C = \prod_{i=1}^{k} \prod_{j=0}^{p-1} M_{i}^{e_{i,j}2^j} \ mod \ N$$
		   Putem să interschimbăm cele două produse și să introducem primul termen într-o paranteză (acest termen din paranteză va reprezenta baza):
		   $$C = \prod_{j=0}^{p-1} \left(   \prod_{i=1}^{k} M_{i}^{e_{i,j}}     \right)^{2^j} \ mod \ N $$
		   Putem face și notația $E=(e_{1,j},...,e_{k,j})$ și vom obține folosind bijecția $b$ :
		   $$ C = \prod_{j=0}^{p-1} b(E)^{2^j}  \ mod \ N$$





\medskip


\begin{thebibliography}{9}
\bibitem{desmet}
Y.Desmedt and Y.Frankel. Share Generation of Authenticators and Signature. In Crypto 91, LNCS 576, paginile 457-469.
\bibitem{boneh}
D.Boneh și M.Franklin. Efficient Generation of Shared RSA keys. In Crypto 97, LNCS 1233, paginile 425-439. Springer-Verlag, 1997

\bibitem{catalano}
D.Catalanoși S.Halevi. Computing Inverses over a Shared Secret Modulus. In Eurocrypt '00, LNCS 1355, paginile 190-207. Springer Verlag, 2000.
\bibitem{cooper}
D.Coppersmith. Finding a small root of a univariate modular equation. In U. M. Maurer, edution EUROCRYPT, volume 1070 of Lecture Notes in Computer Science, pagini 155-165. Springer, 1996
\bibitem{cooper2}
D. Coppersmith. Small solution to polynomial equations, and low exponent RSA vulnerabilities. Journal of Cryptology, paginile 233-260, 1997.
\bibitem{sarkar}
S.Sarkar și S.Maitra. Partial key exposure attacks on RSA and its variants by guessing a fre bits of one of the prime factors. To appear in B-KMS, the Bulletin of Korean Mathematical Society.


\end{thebibliography}

\end{document}